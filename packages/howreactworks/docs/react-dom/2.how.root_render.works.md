---
sidebar_position: 2
---

# How `root.render()` works

To render a UI using React, you should perform the following as the very first steps:

- Create a `root` object using `createRoot`.
- Call the `root.render(ui)` function.

```tsx
import { App } from "./app";
import { createRoot } from "react-dom/client";

const container = document.getElementById("root");

// This is the first step
// highlight-next-line
const root = createRoot(container);

// Then, the second
// highlight-next-line
root.render(<App />);
```

This section is all about the `root.render` function (the second step).
We will see its signature and how it works under the hood.


## Definition
### Declaration

The fiber root `render` method is declared here 
[in `/packages/react-dom/src/client/ReactDOMRoot.js`](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/react-dom/src/client/ReactDOMRoot.js#L102)

### Signature

The `render` method is defined as follows:

```tsx
function render(children: ReactNodeList): void {
  // [Not Native Code]
}
```

As opposed to what we mentally call this parameter the `app` or `ui`, in React
code it is referred as `children`, so let's stick to `children` ðŸ˜‰

The type of this parameter is `ReactNodeList`, [which is](https://github.com/facebook/react/blob/80d9a40114bb43c07d021e8254790852f450bd2b/packages/shared/ReactTypes.js#L22):

```tsx
type ReactNodeList = ReactEmpty | React$Node;

// where:
// highlight-next-line
type ReactEmpty = null | void | boolean;

// and
// highlight-next-line
type React$Node =
  | null
  | boolean
  | number
  | string
  | React$Element<any>
  | React$Portal
  | Iterable<React$Node>;

// where
// highlight-next-line
type React$Element<ElementType extends React$ElementType> = {
  ref: any,
  type: ElementType,
  key: React$Key | null,
  props: React$ElementProps<ElementType>,
}
```

Having this said, we can several things to the `render` method,
[such as the following](https://codesandbox.io/s/crazy-resonance-jph8kc?file=/src/index.js)
or any complex app you used before:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="html" label="index.html">

```html
    <body>
        <div id="root1"></div>
        <hr />
        <div id="root2"></div>
        <hr />
        <div id="root3"></div>
    </body>
```
  </TabItem>
  <TabItem value="js" label="index.js" default>

```tsx
import React, { createElement } from "react";
import { createRoot } from "react-dom/client";

createRoot(document.getElementById("root1")).render([
  "Hello ",
  <span key="world" style={{ color: "red" }}>
    World!
  </span>
]);

class ClassComponent extends React.Component {
  render() {
    const { initialCount } = this.props;

    return <p>Class Count is: {initialCount}</p>;
  }
}

createRoot(document.getElementById("root2")).render([
  <ul key="list">
    <li>First item</li>
    <li>Second</li>
    <li>Last, not third</li>
  </ul>,
  createElement(
    function FunctionComponent({ initialCount }) {
      return <span>Function Count is: {initialCount}</span>;
    },
    { initialCount: 2, key: "count" }
  ),
  <ClassComponent key="class" initialCount={3} />
]);

createRoot(document.getElementById("root3")).render([
  null,
  true,
  false,
  undefined
]);
```
  </TabItem>
</Tabs>

In a nutshell, you would pass a React Element or a collection of them.
React will then `render` them recursively and display your interactive UI.

## Implementation

Before diving in, make sure you've read the previous section about `createRoot`,
we will see many properties mentioned there.

### Purpose

The `render` method is used to inform React to start rendering your application.

### Implementation steps

As you may have noticed if you clicked on the implementation link, the top level
implementation of `render` would:

1. Throw if the `root._internalRoot (FiberRootNode)` is null, which means that
   the `root.unmout` was called (or done manually).
2. Perform some `__DEV__` mode checks and warnings:
   1. If you pass a second argument of type `function`, like the legacy
      `ReactDOM.render(children, callback)`.
   2. If you pass the `children` as a second argument, it guesses that you
      are using the legacy signature.
   3. If you pass anything as a second argument.
3. call `updateContainer(children, root, null, null)`.

```tsx
// simplified
ReactDOMRoot.prototype.render = function render(children: ReactNodeList): void {
    const root = this._internalRoot;
    if (root === null) {
      throw new Error('Cannot update an unmounted root.');
    }
    
    // dev checks
    
    updateContainer(children, root, null, null);
}
```


### `updateContainer`
`updateContainer` is a function called from many places in the React codebase,
you may be wondering why it is called `update` and not `render` or even `mount` ?
It is because for React all the work is done via this function, and if it
detects in a subtree that it is actually a `mount` it will do so.

It is important to analyze this function:

#### Signature

```tsx
export function updateContainer(
  element: ReactNodeList, // children
  container: OpaqueRoot, // OpaqueRoot = FiberRoot = new FiberRootNode
  parentComponent?: React$Component<any, any>,
  callback?: Function,
): Lane {
  // [Not Native Code]
}
```

This function does a lot of things, and is used now when `mounting` a tree
for the first time and later on updates.

The last two parameters were passed as `null` when coming from `root.render`,
which means that they aren't used. We will talk about them only when necessary
though.



### Recap
