---
sidebar_position: 4
---

# How the work loop works

In `how root.render() works` section, the last thing we did is to
schedule via microtask our application's render ( via
`scheduleImmediateTask(processRootScheduleInMicrotask)`).
Or to be more precise, we have a scheduled root with `pending` work stored in 
the global `firstScheduledRoot` variable. 

The work-loop is the process of rendering your components and displaying them
on the screen. The work is triggerred by several actions: `root.render()`,
components updates, recovering from suspense... etc.

Since we are coming from `root.render()`, we will first explain how we
would reach the work loop, and then dive into it.

## How `processRootScheduleInMicrotask` works

When the callstack becomes empty, the javascript event-loop will process the
task queue, and will eventually call the callback [scheduled here.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L120)

If you are wondering, how can they be multiple roots?
It is because React can run in the server too and render for several requests
in parallel. React's code smartly and dangerously plays with globals in order
to unlock many of the concurrent features.

[processRootScheduleInMicrotask](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L233)
will loop over the scheduled roots (in our simple case, the render of a small
application via `root.render()`, there will only one root). And for each root:

```tsx

let root = firstScheduledRoot;
while (root !== null) {
  // perform logic for current root
  
  root = next;
}

```

1. Entangle the root to a `SyncLane` if we are inside a [`popstate` event](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L253).
2. Call `scheduleTaskForRootDuringMicrotask` to get the `nextLanes` for this `root`.
   This function is very important and that's when the work-loop will be
   triggered, we will see it right after.
3. If there is no pending work (`nextLanes === NoLane`), then the root is removed
   from the chain: Remember? We may have multiple roots in a linked list way,
   when there is no pending work to do on a root, it is detached from that list.
4. If there is still work to do, keep this root in the list and verify if it
   contains a sync work.
5. Flush sync work


In summary, here is a simplified version of what happened:

```tsx
// simplified, a lot

const currentTime = Date.now();
let root = firstScheduledRoot;

while (root !== null) {
  const next = root.next;
  // 1
  entangleSyncLaneIfInsidePopStateEvent(root);
  // 2
  const nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
  // 3
  if (nextLanes === NoLane) { // no pending work to do
    detachRootFromScheduledRoots(root);
  } else {
    // 4
    if (includesSyncLane(nextLanes)) {
      mightHavePendingSyncWork = true;
    }
  }
  root = next;
}

// 5
flushSyncWorkOnAllRoots();
```

## How `scheduleTaskForRootDuringMicrotask` works

The second step above did make a call to [this function](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L294)
which is defined as follows:

### Signature

```tsx
function scheduleTaskForRootDuringMicrotask(
  root: FiberRoot,
  currentTime: number,
): Lane { /* [Not Native Code] */ }
```

This function returns the highest priority lane that's scheduled.

### Implementation steps

1. Mark starved lanes as expired
   
   In this process, we will go through the root's `pendingLanes` one by one
   and either compute an expiration time for it if not already computed,
   or else, check if it expired and add it to `root.expiredLanes`:
   ```tsx
   // simplified
   let lanes = pendingLanes & ~RetryLanes;
   while (lanes > 0) {
     // in the following two lines, we will get the index of the highest priority
     // lane from the lanes, and then we will shift 1 by that index so we obtain
     // the current lane with only one significant bit (power of 2)
     const index = pickArbitraryLaneIndex(lanes);
     const lane = 1 << index;
   
     const expirationTime = root.expirationTimes[index];
     
     if (expirationTime !== NoTimestamp) {
       if (
         (lane & suspendedLanes) === NoLanes ||
         (lane & pingedLanes) !== NoLanes
       ) {
         expirationTimes[index] = computeExpirationTime(lane, currentTime);
       }
     } else if (expirationTime <= currentTime) {
       root.expiredLanes |= lane;
     }
   
     lanes &=  ~lane;
   }
   ```
   Check the codebase via [this link.](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L384)

2. Compute the next lanes
   
   Next, React will [compute the next lanes:](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L315)

   ```tsx 
   // When coming from root.render(children)
   const nextLanes = getNextLanes(root, NoLanes);
   ```
3. Exit when there is no pending work or suspended on data
   
   When `nextLanes` are equal to `NoLanes` (which means there is no `pending`
   work to do), or the root is suspended on data, or the root has a scheduled
   pending commit callback (we will see it later) then it will:
   - Cancel the existing callback if any
   - Clean the `root.callbackNode` and `root.callbackPriority` properties
   - return `NoLane`
   
   Read more here on [the real implementation.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L321)
   
4. Exit when there is a Sync pending work
   
   Sync work will be [flushed by `processRootScheduleInMicrotask`](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L344)
   and will be detailed in the next section.
   
   So when a `SyncLane`, we do exactly same as the previous step, and return
   a `SyncLane` rather than `NoLane`.
   
5. Schedule the render on the current root
   
   By here, we have a pending concurrent work to do, then we will compute a
   priority from the `nextLanes`. Wait! what ?
   
   The new `callbackPriority` is implemented now as the `highest priority lane`
   which will be tested against the existing [callback priority](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L358).
   If the priority did not change, React would reuse the same task and priority.
   
   Or else, we would need to infer a `priority` from the `highest priority lane`.
   
   > The highest priority lane is the smallest lane from `nextLanes`.
   
   There are until now [`4` priorities](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactEventPriorities.js#L24):
   ```tsx
   export const DiscreteEventPriority: EventPriority = SyncLane;
   export const ContinuousEventPriority: EventPriority = InputContinuousLane;
   export const DefaultEventPriority: EventPriority = DefaultLne;
   export const IdleEventPriority: EventPriority = IdleLane;
   ```

   Hey! Why we are assigning `Lane`s values to them ? Well, priorities are like
   breakpoints for lanes, which means that we can categorize all lanes into
   `4` groups of priorities.
   
   You can look at the [real implementation here:](https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactEventPriorities.js#L70)

    ```tsx
   // simplified
   const lane = getHighestPriorityLane(nextLanes);
   
   if (DiscreteEventPriority > lane) {
     return DiscreteEventPriority;
   }
   
   if (ContinuousEventPriority > lane) {
     return ContinuousEventPriority;
   }
   
   if (DefaultEventPriority > lane) {
     return DefaultEventPriority;
   }
   
   return IdleEventPriority;
   ```

   Then, we will translate the EventPriority to the [SchedulerPriority:](https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/scheduler/src/SchedulerPriorities.js#L10)

   ```tsx
   switch (lanesToEventPriority(nextLanes)) {
     case DiscreteEventPriority:
       schedulerPriorityLevel = ImmediateSchedulerPriority;
       break;
     case ContinuousEventPriority:
       schedulerPriorityLevel = UserBlockingSchedulerPriority;
       break;
     case DefaultEventPriority:
       schedulerPriorityLevel = NormalSchedulerPriority;
       break;
     case IdleEventPriority:
       schedulerPriorityLevel = IdleSchedulerPriority;
       break;
     default:
       schedulerPriorityLevel = NormalSchedulerPriority;
       break;
   }
   ```
   
   This part is [implemented here.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L376)
   
   
   At this point, we've reached the very last few things to do:
   [Scheduling the work.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L394)

   ```tsx
   const newCallbackNode = scheduleCallback(
     schedulerPriorityLevel,// NormalPriority for simple root.render
     performConcurrentWorkOnRoot.bind(null, root),
   );
   
   root.callbackPriority = newCallbackPriority;
   root.callbackNode = newCallbackNode;
   return newCallbackPriority;
   ```

   We won't talk about `scheduleCallback` here since it is well documented in
   the `how scheduler works` section. `performConcurrentWorkOnRoot` will be
   detailed in a few.
   

:::note
Reminder: After looping over all scheduled roots and re-schedule their render,
`processRootScheduleInMicrotask` will finally [flush sync work on all roots.](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L291)
:::

## How flush sync work on roots works

[This function](https://github.com/facebook/react/blob/7f362de1588d98438787d652941533e21f2f332d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L154)
will loop over all scheduled roots starting from `firstScheduledRoot`, will
exclude any non-legacy roots or those who don't have a `SyncLane` flag.

Then, it will call the [`performSyncWorkOnRoot`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1257)
which will trigger the `sync` work-loop.

We will first start by the `concurrent` work loop then come back to the `sync`
one.

## How the concurrent work loop starts

For the concurrent `root`, the last thing we did is to schedule in
`scheduleTaskForRootDuringMicrotask` a callback to `performConcurrentWorkOnRoot`.

Let's break it.

### `performConcurrentWorkOnRoot` signature

[`performConcurrentWorkOnRoot`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L841)
is defined as follows:

```tsx
export function performConcurrentWorkOnRoot(
  root: FiberRoot,
  didTimeout: boolean,
): RenderTaskFn | null { /* [Not Native Code] */ }
```

The `root` property was bound when scheduling the callback, and the `didTimeout`
will be passed when the scheduler will be calling [this callback.](https://github.com/facebook/react/blob/587ae49d71f218d34393291933d513d2975e22c3/packages/scheduler/src/forks/Scheduler.js#L234)

This function will be rendering your components and performing the whole logic,
so basically it will be insanely long, but we will move some parts from it
to their own sections (like `WorkTags`, `effects` types and implementation
details, and especially`hooks` ).

### Implementation details

1. Guard against calls to this function when already rendering or committing
   ```tsx
   if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
     throw new Error('Should not already be working.');
   }
   ```

2. Flush passive effects

   Effects will be fully discussed in their own section. It will be linked here
   once ready.
   
   ```tsx
   // simplified
   
   // this referencement here because flushPassiveEffects might schedule updates
   const originalCallbackNode = root.callbackNode;
   const didFlushPassiveEffects = flushPassiveEffects();
   
   if (didFlushPassiveEffects && root.callbackNode !== originalCallbackNode) {
     return null;
   }
   ```

   When passive effects are flushed and something did cancel the current
   scheduled callback, this function will stop execution and return `null`.
   
   From the `root.render()` perspective, we have no effects until now, so we
   will continue the execution.

3. Compute again the `nextLanes`
   
   This is a leftover that should be fixed (until now), but the next lanes
   are computed here again (we computed them first above in the
   `scheduleTaskForRootDuringMicrotask` function.)

   And obviously, if there are `NoLanes`, then `null` is returned

4. Determine if it should `time slice`

   To [use time slicing](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L888)
   , the root should not include [`BlockingLanes`](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L475)
   or [`ExpiredLanes`.](https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L491)
   
   Blocking lanes are (per the previous link): `SyncDefaultLanes`,
   `InputContinuousHydrationLane`, `InputContinuousLane`, `DefaultHydrationLane`
   and `DefaultLane`.

   Yes, from `root.render()` without transition we are in `DefaultLane` so this
   render will be considered without time slicing.

5. Call the real render function
   
   Depending on whether it should time slice, it will call `renderRootConcurrent`
   or else it will fall back to `renderRootSync`.

   ```tsx
   let exitStatus = shouldTimeSlice
     ? renderRootConcurrent(root, lanes)
     : renderRootSync(root, lanes);
   ```
6. Finish rendering and perform logic on existStatus

   The possible exitStatus values are [listed here.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L302)
   React will then either [mark the root as suspended](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L903)
   if the render did not complete, or else:
   1. Verify that the render is consistent [with external stores.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L915)
      If not, a sync render [will be performed](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L919)
      
      Then the `while(true)` loop `continue` until a good `existStatus` is
      obtained.
   2. In case of `RootErrored` errors, React will attempt to
      [recover from them if possible.](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L936)
      It will attempt to render again [using `renderRootSync`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L997).
   3. If the `exitStatus` is `RootFatalErrored`: TBD, after renderRoot to know why
   4. Or else, then the tree is consistent and the work is considered as finished
      ```tsx
      // simplified
      
      // React when rendering (we will see in the next section) will store
      // the render work output in a property called alternate in each fiber
      // we will see them in details in a few
      const finishedWork: Fiber = root.current.alternate;
      ```
      This variable is then affected to the finishedWork property of the `root`
      and then `finishConcurrentRender` is called.
      ```tsx
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      finishConcurrentRender(root, exitStatus, finishedWork, lanes);
      ```
      // todo: back to this once renderRoot is done

7. Ensure root is scheduled

   We already saw this in the how `root.render()` works section

8. Return a continuation for the root

   todo: after doing renderRoot and probably move this section afterwards

## How `renderRootSync` works

So, we are finally there! The function that renders our components.

```tsx
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  // [Not Native Code]
}
```

### 1. Mark render started
### 2. Push the context only dispatcher
### 3. Prepare a fresh stack
### 4. Trigger the work loop
### 5. Handle thrown error
### 6. Restore execution context and dispatcher
### 7. Finish the updates

## How `renderRootConcurrent` works
