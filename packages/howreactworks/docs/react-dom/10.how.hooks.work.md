---
sidebar_position: 10
---

# How hooks work

## Introduction
[Hooks](https://react.dev/reference/react/hooks) were introduced in React
v16.8.0, and since then they changed the way React apps were written.
Before them, we used to create class component for anything involving state
or lifecycle logic.
Hooks made function component the new defacto of writing react apps.

They were a huge addition that simplified a lot of things. I am not stating here
that they are better than class components, but they offer a simpler way
to reason about components and to deal with them, and especially they allow
escaping dealing with `this`.

This is not an explanation of React hooks themselves as they are pretty well
documented in the official documentation. We will see how they are written
into React.

## Context
In the previous sections, precisely in how function components get rendered;
we've seen that we set a `Dispatcher` based on whether your component is
mounting for the first time or updating. So first, let's demystify this
dispatcher.

## `ReactCurrentDispatcher`

in the [`renderWithHooks`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556)
function, we set the `ReactCurrentDispatcher.current`. Which is a plain
javascript object with all the hooks implementations that React has.

The goal of having the dispatcher object is to limit the behavior of your hooks'
usage:
- You cannot use hooks outside the render phase: This means that hooks
  won't work if you just decide to call the function component manually when
  React isn't rendering. You are probably familiar with the thrown error.
- Hooks behavior on mount and update isn't the same: as we will see later in
  this section, on mount, the main goal of the dispatcher is to `reserve` as
  place for your hook call and initialize it, but on update it will perform
  the update logic which is different.

Like we said, the dispatcher contains as many properties as React hooks:

```tsx
export const AllDispatchers: Dispatcher = {
  readContext,

  use,
  useCallback: hook,
  useContext: hook,
  useEffect: hook,
  useImperativeHandle: hook,
  useInsertionEffect: hook,
  useLayoutEffect: hook,
  useMemo: hook,
  useReducer: hook,
  useRef: hook,
  useState: hook,
  useDebugValue: hook,
  useDeferredValue: hook,
  useTransition: hook,
  useSyncExternalStore: hook,
  useId: hook,
};
```

There are several dispatchers, but we will only discuss the main four:

- `ContextOnlyDispatcher`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408)
  will prevent you from using hooks outside the render phase. It will throw the
  famous `Invalid hook call` [error.](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440)
- `HooksDispatcherOnMount`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446)
  contains hooks implementation for components when mounting for the first time.
- `HooksDispatcherOnUpdate`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484)
  contains hooks implementation for components when they are updating.
- `HooksDispatcherOnRerender`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522)
  contains hooks implementation when components are re-rendering: when they
  perform a render phase update or when they rendered twice in dev mode.
  

## How hooks are modelled
Each function component may have calls for any of the supported hooks. Remember,
all hooks calls occur withing the `renderWithHooks` function (exception for
the hooks for re-renders, they are called from within the `renderWithHooksAgain`
function).

Hooks are store into the `memoizedState` property of the [related `Fiber`.](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965)

A hook is stored inside React as a plain object with the following properties:

```tsx
const hook: Hook = {
  memoizedState: null,
  
  baseState: null,
  baseQueue: null,
  queue: null,
  
  next: null,
};
```

Where:
- `memoizedState`: contains the hook "state" (or value)
- `baseState`: used by state hooks to store the initial value
- `baseQueue`:
- `queue`:
- `next`: the next hook.

As you may have guessed, the `next` property references in the next hook your
component uses. Thus, hooks are modelled as a linked list of the previous
data structure.

Each hook have its own specification when it comes to what it stores inside
these properties, some hooks don't use all of these properties, obviously.

Notice how this data structure doesn't contain any information about the hook
being used, hooks relies on call order and should ALWAYS be preserved.

![fiber and hook](imgs/10.fiber_and_hook.png)

Dan Abramov wrote an [outstanding blog post](https://overreacted.io/why-do-hooks-rely-on-call-order/)
explaining this design choice.

### Hooks examples

Assuming we are rendering the following component:
```tsx
function MyFunctionComponent(props) {
  const [count, setCount] = React.useState(0);
  // please don't do this, this is only for demo purposes
  const isMounted = React.useRef(false);
  // please don't do this, this is only for demo purposes
  const mountDate = React.useMemo(() => Date.now(), []);
  
  React.useEffect(() => {
    function handler() {
      console.log('window is focused')
    }
    
    window.addEventListener("focus", handler);
    return () => window.removeEventListener("focus", handler);
  }, []);
  
  return <span>Count is {count}</span>
}
```

Rendering this component will result in having a `Fiber` of tag
`FunctionComponent` with the following hooks linked list:

```tsx
let memoizedState = {
  // useState
  "memoizedState": 0,
  "baseState": 0,
  "baseQueue": null,
  "queue": {
    "pending": null,
    "lanes": 0,
    "lastRenderedState": 0
  },
  "next": {
    // useRef
    "memoizedState": {
      "current": false
    },
    "baseState": null,
    "baseQueue": null,
    "queue": null,
    "next": {
      // useMemo
      "memoizedState": [
        1700218172414,
        []
      ],
      "baseState": null,
      "baseQueue": null,
      "queue": null,
      "next": {
        // useEffect
        "memoizedState": {
          "tag": 9,
          "inst": {},
          "deps": [],
          "next": "the same effect .. removed for clarity"
        },
        "baseState": null,
        "baseQueue": null,
        "queue": null,
        "next": null
      }
    }
  }
}
```

## How hooks on mount work
The purpose on hooks on mount as stated before is to grab a place in the linked
list of the hooks.

So, all hooks implementations on mount will first perform the following:

```tsx
const hook = mountWorkInProgressHook();
```

The `mountWorkInProgressHook` function will create the previous data structure
and then set is as the `memoizedState` property of the `currentlyRenderingFiber`.

### `mountWorkInProgressHook` Implementation

The mount in progress hook function is implemented as follows:

```tsx
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

- First, it will create the hook object
- Then, if it is the first hook of the list, it will attach it to the
  `memoizedState` of the `currentlyRenderingFiber` and set this hook at the
  `workInProgressHook`
- Or else, it will attach it to the `next` property of the `workInProgressHook`.

And that's it!

Depending on the hook, other things will be performed, we will see them
separately for each supported hook.

## How hooks on update work

When your component is updating (not its first ever render), each supported
hook call will start with the following expression then will follow up with
the specific work.

```tsx
const hook = updateWorkInProgressHook();
```

[`updateWorkInProgressHook`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973)
is a bit more complex than the mount one, but its purpose it to detect the next
`workInProgressHook` too. it used for both updates and re-renders, so it assumes
that there is either a `current` hook object that can be cloned or a 
`work-in-progress` from a previous render that can be reused.

The first part of this function then is to find the currently rendered hook
value. It will check the `current` rendered fiber's `memoizedState`
property if the `currentHook` module variable is null, or else it takes its
`next` property:

```tsx
// at module level:
let currentHook: null | Hook = null;

// inside updateWorkInProgressHook

let nextCurrentHook: null | Hook;
if (currentHook === null) {
  // the current rendered fiber
  const current = currentlyRenderingFiber.alternate;
  
  // already mounted
  if (current !== null) {
    nextCurrentHook = current.memoizedState;
  } else {
    // first mount
    nextCurrentHook = null;
  }
  
} else {
  nextCurrentHook = currentHook.next;
}
```

Now, after detecting the current rendered (painted) hook value, React will
then try to find its alternate (the being rendered one):

```tsx
// at module level:
let workInProgressHook: null | Hook = null;

// inside updateWorkInProgressHook
let nextWorkInProgressHook: null | Hook;

// first hook of the list, take it from the being rendered fiber
if (workInProgressHook === null) {
  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
} else {
  // or else, it is the next hook
  nextWorkInProgressHook = workInProgressHook.next;
}
```
It is important to note that when we start updating a component, the memoized
state property is reset and set to null.

Now, we have the currently painted hook value, and the being rendered one.

When there is a `nextWorkInProgressHook`, this means that we already have
started rendering then we are rendering again without committing and finishing
the render, and thus, we will reuse it as is:

```tsx
if (nextWorkInProgressHook !== null) {
  // There's already a work-in-progress. Reuse it.
  workInProgressHook = nextWorkInProgressHook;
  nextWorkInProgressHook = workInProgressHook.next;

  currentHook = nextCurrentHook;
}
```

Or else, if the `nextCurrentHook` is null, that we are rendering more hooks
than the previous render, which is against hooks rules, and then React will
throw an error.
When `nextCurrentHook` isn't null, this means that we should clone the previous
hook and use it as a base:

```tsx
// React code

if (nextWorkInProgressHook !== null) {
  // previous code
} else {
  if (nextCurrentHook === null) {
    const currentFiber = currentlyRenderingFiber.alternate;
    if (currentFiber === null) {
      // This is the initial render. This branch is reached when the component
      // suspends, resumes, then renders an additional hook.
      // Should never be reached because we should switch to the mount dispatcher first.
      throw new Error(
              'Update hook called on initial render. This is likely a bug in React. Please file an issue.',
      );
    } else {
      // This is an update. We should always have a current hook.
      throw new Error('Rendered more hooks than during the previous render.');
    }
  }

  currentHook = nextCurrentHook;

  // clone from the currently painted hook
  const newHook: Hook = {
    memoizedState: currentHook.memoizedState,

    baseState: currentHook.baseState,
    baseQueue: currentHook.baseQueue,
    queue: currentHook.queue,

    next: null,
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list.
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
  } else {
    // Append to the end of the list.
    workInProgressHook = workInProgressHook.next = newHook;
  }
}
```

## How hooks on rerender work

Re-rendering components is an internal term in the React codebase that means
that the component either scheduled a render phase update or that we are
replaying it in development mode.

If you take a close look at the `HooksDispatcherOnRerender` dispatcher, you will
notice that it is the same as the `HooksDispatcherOnUpdate` except for:
`useReducer: rerenderReducer`, `useState: rerenderState`,
`useDeferredValue: rerenderDeferredValue` and `useTransition: rerenderTransition`.

This dispatcher is set from the [`renderWithHooksAgain`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771)
function. I will just copy Andrew's comment about this function:

```tsx
// This is used to perform another render pass. It's used when setState is
// called during render, and for double invoking components in Strict Mode
// during development.
//
// The state from the previous pass is reused whenever possible. So, state
// updates that were already processed are not processed again, and memoized
// functions (`useMemo`) are not invoked again.
//
// Keep rendering in a loop for as long as render phase updates continue to
// be scheduled. Use a counter to prevent infinite loops.
```

## How each hook works

We will follow the presence of hooks in the dispatchers order to explain them.

import TBD from "./components/TBDBanner"

## How use works
The `use` hook is a new hook that will replace the `throw promise` pattern
introduced for suspending components that still wait for data.

Suspending using `throw promise` was there since too long, but was never
official, and this hook is introduced as a viable alternative.

### Signature

The `use` hook is [defined here](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1093).

```tsx
function use<T>(usable: Usable<T>): T {
  // [Not Native Code]
}
```

It accepts either a promise or context type.

:::tip
The use hook doesn't rely on `mountWorkInProgressHook` and `updateWIPHook`, so
it can be called conditionally and doesn't obey the rules of hooks.
:::

### Implementation

As stated before, `use` accepts `thenabled` and `Context`:

#### Context
When the provided object to `use` is a React `Context`, it will just delegate
the work to the `readContext` function. It will be discussed and explained
in the `useContext` section.

```tsx
if (
  usable.$$typeof === REACT_CONTEXT_TYPE ||
  usable.$$typeof === REACT_SERVER_CONTEXT_TYPE
) {
  const context: ReactContext<T> = usable;
  return readContext(context);
}
```

So, `use` will allow you to conditionally subscribe to a context while escaping
the rules of hooks 🤯

#### Thenable

When a thenable object is provided, React will call the [internal `useThenable`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1066)
function:

```tsx
function use<T>(usable: Usable<T>): T {
  if (usable !== null && typeof usable === 'object') {
    if (typeof usable.then === 'function') {
      const thenable: Thenable<T> = usable;
      return useThenable(thenable);
    }
    // ... other code
  }

  throw new Error('An unsupported type was passed to use(): ' + String(usable));
}
```

We've reached a point where the `useThenable` function is clearly behind
the `use` hook's work:

Besides of initializing and incrementing the thenable state (which I will not
explain now), useThenable calls [`trackUsedThenable`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberThenable.js#L69)
which will do the whole work.

```tsx
function useThenable<T>(thenable: Thenable<T>): T {
  // Track the position of the thenable within this fiber.
  const index = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    // createThenableState returns a plain javascript array
    thenableState = createThenableState();
  }
  // highlight-next-line
  const result = trackUsedThenable(thenableState, thenable, index);
  // ... other code
  return result;
}

```

Let's then dive into `trackUsedThenable`:

1. Part 1: Add the thenable to the array of thenables:
   
   Please pay attention to Sophie's comment: if the there was a thenable at
   the same position, we will reuse the former one because they should
   technically point to the same value. Don't ask me of this design choice.
   ```tsx
   const previous = thenableState[index];
     if (previous === undefined) {
       thenableState.push(thenable);
     } else {
       if (previous !== thenable) {
         // Reuse the previous thenable, and drop the new one. We can assume
         // they represent the same value, because components are idempotent.
   
         // Avoid an unhandled rejection errors for the Promises that we'll
         // intentionally ignore.
         thenable.then(noop, noop);
         thenable = previous;
       }
     }
   ```
   
2. Part 2: Track the thenable
   There are two cases, whether we previously tracked this thenable, or it is
   the first time we encounter it.

   Tracking the thenable is adding a `then(onFullfilement, onRejection)`
   callbacks that will mutate the thenable itself:

   Read well the following code and grasp it:
   ```tsx
   const pendingThenable: PendingThenable<T> = thenable;
   pendingThenable.status = 'pending';
   pendingThenable.then(
     fulfilledValue => {
       if (thenable.status === 'pending') {
         const fulfilledThenable: FulfilledThenable<T> = thenable;
         fulfilledThenable.status = 'fulfilled';
         fulfilledThenable.value = fulfilledValue;
       }
     },
     (error: mixed) => {
       if (thenable.status === 'pending') {
         const rejectedThenable: RejectedThenable<T> = thenable;
         rejectedThenable.status = 'rejected';
         rejectedThenable.reason = error;
       }
     },
   );
   ```
   But before tracking like this, if the thenable was already tracked, we only
   verify its status:

   ```tsx
   switch (thenable.status) {
     case 'fulfilled': {
       const fulfilledValue: T = thenable.value;
       return fulfilledValue;
     }
     case 'rejected': {
       const rejectedError = thenable.reason;
       checkIfUseWrappedInAsyncCatch(rejectedError);
       throw rejectedError;
     }
     // ... other code
   }
   ```
   - When status is `fulfilled`, the `use` hook will return the value
   - When status is `rejected`, the `use` hook will throw the error
   
   When the status is `pending`, React will throw a special exception object
   called `SuspenseException` to suspend the tree until the thenable resolves
   or rejects.

   This will lead to the component rendering only if it has data, and throwing
   in the other cases.

   :::note
   The use hook will require you to put an Error boundary in the tree to
   intercept rejections.
   :::

:::warning
The `use` hook will require you to manually cache/memoize the promises.

The `React.cache` experimental API is designed to help you with that.
:::

### Examples

Let's say we want to get the user details from the public jsonplaceholder API.

To achieve that, we will create a small cache to help us memoizing the promises
and thus avoid infinite renders. So, let's create a dumb memoizer for functions:

```tsx
// we assume that we will cache with one parameter
// which will be the user id.
// React.cache is a general solution for this.
// for clarity, we'll use only userId
function createCache(asyncFunc) {
  let cache = {};

  return function exec(...args) {
    let cacheId = args[0];
    let existing = cache[cacheId];
    if (existing) {
      return existing;
    }

    let result = asyncFunc.apply(null, args);
    cache[cacheId] = result;
    return result;
  };
}
```

Let's then create a dumb error boundary for that too:

```tsx
class ErrorBoundary extends React.Component {
  state = { error: null };
  componentDidCatch(error) {
    this.setState((prev) => ({ ...prev, error }));
  }
  render() {
    const { error } = this.state;
    if (error) {
      return (
        <>
          <pre>{error.toString()}</pre>
          <button
            onClick={() => this.setState((prev) => ({ ...prev, error: null }))}
          >
            Reset
          </button>
        </>
      );
    }
    return this.props.children;
  }
}
```

And finally, let's exploit this code:

```tsx
async function fetchUserById(userId) {
  let result = await axios.get(
    `https://jsonplaceholder.typicode.com/users/${userId}`
  );
  return result.data;
}

let getUserDetails = createCache(fetchUserById);

let IDS = [1, 2, 3, 4, 5, 10, 11];

function UserDetails({ id }) {
  let details = React.use(getUserDetails(id));

  return (
    <details open>
      <pre>{JSON.stringify(details, null, 4)}</pre>
    </details>
  );
}
function Example() {
  let [userId, setUserId] = React.useState(IDS[0]);
  return (
    <div className="App">
      {IDS.map((id) => (
        <button
          onClick={() => {
            setUserId(id);
          }}
          key={id}
        >
          {`User ${id}`}
        </button>
      ))}
      <React.Suspense fallback={`Loading user ${userId}`}>
        <UserDetails id={userId} />
      </React.Suspense>
    </div>
  );
}

export default function App() {
  return (
    <ErrorBoundary>
      <Example />
    </ErrorBoundary>
  );
}
```

You can view and manipulate this [demo here:](https://codesandbox.io/s/lucid-curran-x8xxlj?file=/src/App.js)

<iframe src="https://codesandbox.io/embed/lucid-curran-x8xxlj?fontsize=14&hidenavigation=1&theme=dark"
style={{width: "100%", height: "500px", border: 0, borderRadius: 4}}
title="React.use demo"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

## How useCallback works
The `useCallback` hook allows you to keep a function reference until 
a dependency changes.

### Signature
`useCallback` is defined as follows:

```tsx
function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

The previous function doesn't exist directly, as stated before, there is
[`mountCallback` ](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2602)
and [`updateCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2609)
functions, with the same signature:

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

### Implementation
#### On mount
When your component renders for the first time while using `useCallback`, the
call will be intercepted by `mountCallback`, which is probably the easiest hook:

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **Step 1**: Mount the hook data structure seen in the top of this section
- **Step 2**: Define the dependencies to use, if the parameter is omitted, `null`
  is used.
- **Step 2**: Store the callback and dependencies in the `memoizedState` of the
  hook.

`useCallback` will return whatever value you throw at it, usually we give either
an inline function defined directly there, or a function defined in the component
body.

So, in mount, useCallback don't care about your dependencies, it will only
store them for later usage.

#### On Update
On updates, the goal is to give you a new function reference **only** if
one dependency changes.

```tsx
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // step 1
  // highlight-next-line
  const hook = updateWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  // step 3
  // highlight-next-line
  if (nextDeps !== null) {
    const prevDeps: Array<mixed> | null = prevState[1];
    // step 4
    // highlight-next-line
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  // step 5
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **Step 1**: Create or reuse the hook data structure object.
- **Step 2**: Infer the dependencies array, or `null` if nothing is provided.
- **Step 3**: When dependencies aren't null, which means that we are memoizing
  things (undefined as second argument means that we won't memoize anything), we
  will proceed to compare them with the previous deps.
- **Step 4**: This compares the previous and next dependencies, if they are
  the same, the previous value (the first element in the `memoizedState` array)
  is returned. We'll see the comparison in a few.
- **Step 5**: When dependencies changed or that we aren't using them, similarly
  to `mountCallback`, we store `[callback, nextDeps]` into the `memoizedState`
  property of the hook object.

The [`areHookInputsEqual`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L451)
function is used in all hooks that use the dependencies array. It will:

- Always `return` false when there are no previous dependencies, which instructs
  React to recompute the hook returned value. In human words, this means that
  our hook doesn't use any dependencies and will be refreshed every render.
- Loop over both arrays and use `Object.is` to compare individual values.

## How useContext works
The [`useContext` hook](https://react.dev/reference/react/useContext) allows you
to read and subscribe to a [React Context](https://medium.com/@mohamedelayadi/react-context-all-you-need-to-know-40de6662b074)
value.

### Signature

[`useContext` hook](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L713)
is defined as follows:

```tsx
function readContext<T>(context: ReactContext<T>): T {
  // [Not Native Code]
}
```

Where the unique parameter refers to a React context object created by the
[`React.createContext` API.](https://react.dev/reference/react/createContext)

### Implementation
`useContext` uses the [`readContextForConsumer`](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L740)
function:

```tsx
export function readContext<T>(context: ReactContext<T>): T {
  // ...dev checks
  return readContextForConsumer(currentlyRenderingFiber, context);
}
```

The `readContextForConsumer` is responsible for giving you the current context
value and also subscribe to it for future changes. Let's dig into its
implementation:

```tsx
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>,
): T {
  
  // step 1
  // highlight-next-line
  const value = isPrimaryRenderer
    ? context._currentValue
    : context._currentValue2;

  // step 2
  // highlight-next-line
  if (lastFullyObservedContext === context) {
    // Nothing to do. We already observe everything in this context.

  // step 3
  // highlight-next-line
  } else {
    
  }
}
```

- **Step 1**: Decides on the internal context value based on the
  `isPrimaryRenderer` renderer property. I don't have much experience with this
  property, but you set it while creating a custom React renderer. Primary means
  that your renderer renders the whole page, and secondary means that you are
  writing a renderer meant to be used on top of another one. In our case, which
  is React-DOM, it is a primary renderer, so we take the `_currentValue` value.
- **Step 2**: The second step will actually bail out reading and subscribing to
  this context. React uses the `lastFullyObservedContext` module variable, which
  [seems to be unused](https://github.com/search?q=repo%3Afacebook%2Freact%20lastFullyObservedContext&type=code).
  I mean, I haven't seen it being written in the whole codebase.
- **Step 3**: The third step is where subscription occurs, let's dig into it.

### How Context subscription works

The context subscription is stored in the `fiber.dependencies` property in
a linked list fashion (again):

```tsx
// simplified
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>,
): T {
  const value = context._currentValue;

  const contextItem = {
    context: (context as ReactContext<any>),
    memoizedValue: value,
    next: null,
  };
}
```

Then, when this is the first `useContext` in this component, it will add the
following object as `dependencies`:

```tsx
// simplified

// the lastContextDependency variable is reset in the prepareToReadContext
// function called when we are about to update components
// (updateFunctionComponent and others)
if (lastContextDependency === null) {
  lastContextDependency = contextItem;
  // consumer is the work in progress fiber
  consumer.dependencies = {
    lanes: NoLanes,
    firstContext: contextItem
  }
}
```

Or else, it will add the context item as the `next` property of the previous one:

```tsx
if (lastContextDependency === null) {
  // ...
} else {
  lastContextDependency = lastContextDependency.next = contextItem;
}
```

And that's it!

### Updates
When a component rendering a `ContextProvider` gets updated, React will check
on the `value` `prop`, and if it changed, it will propagate the changes.

This section will be explained in how rendering of a `ContextProvider` works.

:::note
Similarly to the `use` hook, `useContext` can be called conditionally on render.

But you cannot call it inside other hooks or outside the render phase. Because
it needs the currently rendering fiber to be able to perform subscription.
:::

## How useEffect works
<TBD />

## How useImperativeHandle works
<TBD />

## How useInsertionEffect works
<TBD />

## How useLayoutEffect works
<TBD />

## How useMemo works
<TBD />

## How useReducer works
<TBD />

## How useRef works
<TBD />

## How useState works
<TBD />

## How useDebugValue works
<TBD />

## How useDeferredValue works
<TBD />

## How useTransition works
<TBD />

## How useSyncExternalStore works
<TBD />

## How useId works
<TBD />

## Annex

This is a table for all the internal stored value for all hooks:

| Hook                   | `memoizedState`    | Comment(s)                                                                                       |
|------------------------|--------------------|--------------------------------------------------------------------------------------------------|
| `use`                  | `N/A`              | `use` doesn't obey the rules of hooks and does not use the internal data structure               |
| `useCallback`          | `[callback, deps]` | `useCallback` saves the passed callback and dependencies                                         |
| `useContext`           | `N/A`              | `useContext` doesn't rely on hooks call order, it is stored in the `fiber.dependencies` property |
| `useEffect`            | `TBD`              |                                                                                                  |
| `useImperativeHandle`  | `TBD`              |                                                                                                  |
| `useLayoutEffect`      | `TBD`              |                                                                                                  |
| `useInsertionEffect`   | `TBD`              |                                                                                                  |
| `useMemo`              | `TBD`              |                                                                                                  |
| `useReducer`           | `TBD`              |                                                                                                  |
| `useRef`               | `TBD`              |                                                                                                  |
| `useState`             | `TBD`              |                                                                                                  |
| `useDebugValue`        | `TBD`              |                                                                                                  |
| `useDeferredValue`     | `TBD`              |                                                                                                  |
| `useTransition`        | `TBD`              |                                                                                                  |
| `useSyncExternalStore` | `TBD`              |                                                                                                  |
| `useId`                | `TBD`              |                                                                                                  |


