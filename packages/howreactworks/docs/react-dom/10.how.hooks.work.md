---
sidebar_position: 10
---

# フックの仕組み

## はじめに

React v16.8.0 で導入された[フック](https://react.dev/reference/react/hooks)は、React アプリの書き方を変革しました。フック以前は、ステートやライフサイクルロジックが必要な場合、クラスコンポーネントを使用する必要がありました。フックの登場により、ファンクションコンポーネントが React アプリ開発のデファクトスタンダードとなりました。

フックは多くのことをシンプルにしました（クラスコンポーネントより優れていると言っているわけではありません）。コンポーネントの推論や扱いを容易にし、`this`の扱いから解放されるなどの利点があります。

公式ドキュメントでフック自体の説明は十分されているため、ここでは React 内部での実装方法に焦点を当てます。

## コンテキスト

前章の「ファンクションコンポーネントのレンダリング方法」で、コンポーネントが初回マウント時か更新時かに基づいて`Dispatcher`を設定することを説明しました。この Dispatcher の正体を解明しましょう。

## `ReactCurrentDispatcher`

[`renderWithHooks`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556)関数内で、`ReactCurrentDispatcher.current`を設定します。これは React のすべてのフック実装を含むプレーンな JavaScript オブジェクトです。

Dispatcher オブジェクトの目的は、フックの使用を制限することにあります：

- レンダーフェーズ外でのフック使用を禁止（手動でファンクションコンポーネントを呼び出した場合など）
- マウント時と更新時で異なるフックの挙動（マウント時はフックの位置確保と初期化、更新時は更新ロジックの実行）

Dispatcher には React のフックに対応するプロパティが含まれます：

```tsx
export const AllDispatchers: Dispatcher = {
  readContext,

  use,
  useCallback: hook,
  useContext: hook,
  useEffect: hook,
  useImperativeHandle: hook,
  useInsertionEffect: hook,
  useLayoutEffect: hook,
  useMemo: hook,
  useReducer: hook,
  useRef: hook,
  useState: hook,
  useDebugValue: hook,
  useDeferredValue: hook,
  useTransition: hook,
  useSyncExternalStore: hook,
  useId: hook,
};
```

Dispatcher にはいくつかの種類がありますが、主に 4 つを解説します：

- `ContextOnlyDispatcher`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408)
  はレンダーフェーズ外でのフック使用を防ぎます。いわゆる「Invalid hook call」[エラー](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440)をスローします
- `HooksDispatcherOnMount`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446)
  はコンポーネントが初回マウントされる際のフック実装を含みます
- `HooksDispatcherOnUpdate`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484)
  はコンポーネントが更新される際のフック実装を含みます
- `HooksDispatcherOnRerender`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522)
  は以下の場合の再レンダー時に使用されます：
  - レンダーフェーズ中に状態更新が発生した場合
  - 開発モードでコンポーネントが 2 回レンダリングされる場合

## フックのモデリング

各ファンクションコンポーネントはサポートされているフックを呼び出せます。すべてのフック呼び出しは`renderWithHooks`関数内で発生します（再レンダー用のフックは`renderWithHooksAgain`関数から呼び出される例外を除く）。

フックは[関連する`Fiber`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965)の`memoizedState`プロパティに保存されます。

フックは React 内部で以下のプロパティを持つプレーンオブジェクトとして保存されます：

```tsx
const hook: Hook = {
  memoizedState: null,

  baseState: null,
  baseQueue: null,
  queue: null,

  next: null,
};
```

各プロパティの役割：

- `memoizedState`: フックの「ステート」（または値）を保持
- `baseState`: ステートフックが初期値を保存するために使用
- `baseQueue`:
- `queue`: ステートフックが様々な情報を保存するための UpdateQueue オブジェクト
- `next`: 次のフックを指す

`next`プロパティがコンポーネントで使用する次のフックを参照することから、フックは前述のデータ構造のリンクリストとしてモデリングされています。

各フックはこれらのプロパティに何を保存するかについて独自の仕様を持ち、明らかにすべてのプロパティを使用しないフックもあります。

このデータ構造にはフックの種類に関する情報が含まれていないことに注目してください。フックは呼び出し順序に依存し、常に保存される必要があります。

![fiber and hook](imgs/10.fiber_and_hook.png)

Dan Abramov はこの設計選択について[優れたブログ記事](https://overreacted.io/why-do-hooks-rely-on-call-order/)を書いています。

### フックの例

以下のコンポーネントをレンダリングすると仮定します：

```tsx
function MyFunctionComponent(props) {
  const [count, setCount] = React.useState(0);
  // デモ用のため実際には推奨されません
  const isMounted = React.useRef(false);
  // デモ用のため実際には推奨されません
  const mountDate = React.useMemo(() => Date.now(), []);

  React.useEffect(() => {
    function handler() {
      console.log("window is focused");
    }

    window.addEventListener("focus", handler);
    return () => window.removeEventListener("focus", handler);
  }, []);

  return <span>Count is {count}</span>;
}
```

このコンポーネントをレンダリングすると、`FunctionComponent`タグの`Fiber`が生成され、以下のようなフックのリンクリストが作成されます：

```tsx
let memoizedState = {
  // useState
  memoizedState: 0,
  baseState: 0,
  baseQueue: null,
  queue: {
    pending: null,
    lanes: 0,
    lastRenderedState: 0,
  },
  next: {
    // useRef
    memoizedState: {
      current: false,
    },
    baseState: null,
    baseQueue: null,
    queue: null,
    next: {
      // useMemo
      memoizedState: [1700218172414, []],
      baseState: null,
      baseQueue: null,
      queue: null,
      next: {
        // useEffect
        memoizedState: {
          tag: 9,
          inst: {},
          deps: [],
          next: "the same effect .. removed for clarity",
        },
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      },
    },
  },
};
```

## マウント時のフックの仕組み

マウント時のフックの目的は、リンクリストのフックの位置を確保することです。

そのため、すべてのフック実装はマウント時に以下の処理を最初に行います：

```tsx
const hook = mountWorkInProgressHook();
```

`mountWorkInProgressHook`関数は前述のデータ構造を作成し、それを`currentlyRenderingFiber`の`memoizedState`プロパティに設定します。

### `mountWorkInProgressHook`の実装

マウント中のフック関数は以下のように実装されています：

```tsx
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // これはリストの最初のフックです
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // リストの末尾に追加
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

- 最初にフックオブジェクトを作成します
- その後、リストの最初のフックである場合、それを`currentlyRenderingFiber`の`memoizedState`にアタッチし、`workInProgressHook`にも設定します
- それ以外の場合、`workInProgressHook`の`next`プロパティにアタッチします

以上です！

フックによっては、他の処理も行われますが、それぞれのサポートされるフックについて別々に説明します。

## 更新時のフックの仕組み

コンポーネントが更新される（初回レンダリングではない）場合、各サポートされるフック呼び出しは以下の式で始まり、その後に特定の処理が続きます。

```tsx
const hook = updateWorkInProgressHook();
```

[`updateWorkInProgressHook`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973)
はマウントよりも複雑ですが、目的は次の`workInProgressHook`を検出することです。これは更新と再レンダリングの両方に使用され、前回のレンダリングから`current`フックオブジェクトをクローンするか、`work-in-progress`を再利用するかを想定しています。

この関数の最初の部分では、現在のレンダリングされたフックの値を検出します。`currentHook`モジュール変数が null の場合、`current`レンダリング済みファイバーの`memoizedState`プロパティをチェックします。それ以外の場合は、その`next`プロパティを取得します：

```tsx
// モジュールレベルで：
let currentHook: null | Hook = null;

// updateWorkInProgressHook内で：

let nextCurrentHook: null | Hook;
if (currentHook === null) {
  // 現在のレンダリング済みファイバー
  const current = currentlyRenderingFiber.alternate;

  // すでにマウント済みの場合
  if (current !== null) {
    nextCurrentHook = current.memoizedState;
  } else {
    // 初回マウントの場合
    nextCurrentHook = null;
  }
} else {
  nextCurrentHook = currentHook.next;
}
```

これで、現在のレンダリング済み（ペイント済み）フックの値を検出したので、React は次にその代替（レンダリング中のもの）を検出します：

```tsx
// モジュールレベルで：
let workInProgressHook: null | Hook = null;

// updateWorkInProgressHook内で：
let nextWorkInProgressHook: null | Hook;

// リストの最初のフックの場合、レンダリング中のファイバーから取得
if (workInProgressHook === null) {
  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
} else {
  // それ以外の場合、次のフック
  nextWorkInProgressHook = workInProgressHook.next;
}
```

コンポーネントを更新する際、memoizedState プロパティはリセットされ、null に設定されます。

これで、現在のペイント済みフックの値と、レンダリング中のものを持つことができました。

`nextWorkInProgressHook`がある場合、これはすでにレンダリングを開始していて、コミットやレンダリングの終了なしに再度レンダリングしていることを意味し、そのまま再利用します：

```tsx
if (nextWorkInProgressHook !== null) {
  // すでにワークインプログレスがあります。再利用します。
  workInProgressHook = nextWorkInProgressHook;
  nextWorkInProgressHook = workInProgressHook.next;

  currentHook = nextCurrentHook;
}
```

それ以外の場合、`nextCurrentHook`が null の場合、前回のレンダリングよりもフックを多くレンダリングしていることを意味し、フックの規則に反することになり、React はエラーをスローします。
`nextCurrentHook`が null でない場合、前回のレンダリングのフックをクローンして基にする必要があります：

```tsx
// Reactのコード

if (nextWorkInProgressHook !== null) {
  // 前のコード
} else {
  if (nextCurrentHook === null) {
    const currentFiber = currentlyRenderingFiber.alternate;
    if (currentFiber === null) {
      // これは初回レンダリングです。このブランチは、コンポーネントが一時停止し、再開してから追加のフックをレンダリングするときに到達します。
      // このブランチに到達することはありません。最初にマウントディスパッチャーに切り替える必要があります。
      throw new Error(
        "Update hook called on initial render. This is likely a bug in React. Please file an issue."
      );
    } else {
      // これは更新です。常に現在のフックがあるはずです。
      throw new Error("Rendered more hooks than during the previous render.");
    }
  }

  currentHook = nextCurrentHook;

  // 現在のペイント済みフックからクローン
  const newHook: Hook = {
    memoizedState: currentHook.memoizedState,

    baseState: currentHook.baseState,
    baseQueue: currentHook.baseQueue,
    queue: currentHook.queue,

    next: null,
  };

  if (workInProgressHook === null) {
    // これはリストの最初のフックです。
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
  } else {
    // リストの末尾に追加
    workInProgressHook = workInProgressHook.next = newHook;
  }
}
```

## 再レンダリング時のフックの仕組み

コンポーネントの再レンダリングという用語は、React コードベース内ではレンダーフェーズの更新をスケジュールしたか、開発モードで再生していることを意味します。

`HooksDispatcherOnRerender`ディスパッチャーを見ると、`useReducer: rerenderReducer`, `useState: rerenderState`, `useDeferredValue: rerenderDeferredValue`, `useTransition: rerenderTransition`以外は`HooksDispatcherOnUpdate`と同じであることがわかります。

このディスパッチャーは[`renderWithHooksAgain`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771)関数から設定されます。Andrew のコメントをコピーします：

```tsx
// これは別のレンダーパスを実行するためのものです。レンダーフェーズの更新が呼び出されたとき、または開発モードでコンポーネントがレンダーフェーズで2回レンダリングされるときに使用されます。
//
// 前回のパスの状態は可能な限り再利用されます。そのため、すでに処理された状態更新は再度処理されず、メモ化された関数（`useMemo`）は再度呼び出されません。
//
// レンダーフェーズの更新がスケジュールされ続ける限り、ループでレンダリングを続けます。無限ループを防ぐためにカウンターを使用します。
```

## 各フックの仕組み

ディスパッチャーの存在順に従って、各フックを説明します。

import TBD from "./components/TBDBanner"

## `use`フックの仕組み

`use`フックは、データを待っている間にスローされる`throw promise`パターンを置き換える新しいフックです。

`throw promise`は長くから存在していましたが、公式ではなく、このフックは公式の代替として導入されました。

### シグネチャ

`use`フックは[ここで定義されています](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1093)。

```tsx
function use<T>(usable: Usable<T>): T {
  // [Not Native Code]
}
```

Promise または Context 型のオブジェクトを受け入れます。

:::tip
`use`フックは`mountWorkInProgressHook`と`updateWIPHook`に依存しないため、条件付きで呼び出すことができ、フックの規則に従わなくなります。
:::

### 実装

前述のように、`use`は`thenabled`と`Context`の両方を受け入れます：

#### Context

`use`に渡されたオブジェクトが React の`Context`である場合、`readContext`関数に処理を委譲します。これは`useContext`セクションで説明します。

```tsx
if (
  usable.$$typeof === REACT_CONTEXT_TYPE ||
  usable.$$typeof === REACT_SERVER_CONTEXT_TYPE
) {
  const context: ReactContext<T> = usable;
  return readContext(context);
}
```

そのため、`use`を使用すると条件付きでコンテキストにサブスクライブでき、フックの規則を回避できます 🤯

#### Thenable

Thenable オブジェクトが提供された場合、React は[内部の`useThenable`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1066)関数を呼び出します：

```tsx
function use<T>(usable: Usable<T>): T {
  if (usable !== null && typeof usable === "object") {
    if (typeof usable.then === "function") {
      const thenable: Thenable<T> = usable;
      return useThenable(thenable);
    }
    // ... other code
  }

  throw new Error("An unsupported type was passed to use(): " + String(usable));
}
```

`useThenable`関数が`use`フックの仕事の背後にあることが明らかになりました。

初期化と thenable 状態のインクリメント（これについては説明しません）の後、`useThenable`は[`trackUsedThenable`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberThenable.js#L69)を呼び出し、これがすべての仕事を行います。

```tsx
function useThenable<T>(thenable: Thenable<T>): T {
  // このファイバー内でthenableの位置を追跡します。
  const index = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    // createThenableStateはプレーンなJavaScript配列を返します
    thenableState = createThenableState();
  }
  // highlight-next-line
  const result = trackUsedThenable(thenableState, thenable, index);
  // ... other code
  return result;
}
```

それでは`trackUsedThenable`について説明します：

1. パート 1：thenable を配列に追加する

   ソフィーのコメントに注意してください。同じ位置に thenable があった場合、技術的には同じ値を指すはずですので、前者を再利用します。この設計選択について聞かれたら答えられません。

   ```tsx
   const previous = thenableState[index];
   if (previous === undefined) {
     thenableState.push(thenable);
   } else {
     if (previous !== thenable) {
       // 前のthenableを再利用し、新しいものを捨てます。コンポーネントは恒等であると仮定できます。

       // 意図的に無視するPromiseの未処理の拒否エラーを避けるために、それらを処理します。
       thenable.then(noop, noop);
       thenable = previous;
     }
   }
   ```

2. パート 2：thenable を追跡する
   前に thenable を追跡したことがあるか、初めて遭遇したかによって、2 つのケースがあります。

   thenable を追跡することは、thenable 自体を変更する`then(onFullfilement, onRejection)`コールバックを追加することを意味します：

   以下のコードをよく読んで理解してください：

   ```tsx
   const pendingThenable: PendingThenable<T> = thenable;
   pendingThenable.status = "pending";
   pendingThenable.then(
     (fulfilledValue) => {
       if (thenable.status === "pending") {
         const fulfilledThenable: FulfilledThenable<T> = thenable;
         fulfilledThenable.status = "fulfilled";
         fulfilledThenable.value = fulfilledValue;
       }
     },
     (error: mixed) => {
       if (thenable.status === "pending") {
         const rejectedThenable: RejectedThenable<T> = thenable;
         rejectedThenable.status = "rejected";
         rejectedThenable.reason = error;
       }
     }
   );
   ```

   しかし、thenable が既に追跡されている場合、単にその状態を確認します：

   ```tsx
   switch (thenable.status) {
     case "fulfilled": {
       const fulfilledValue: T = thenable.value;
       return fulfilledValue;
     }
     case "rejected": {
       const rejectedError = thenable.reason;
       checkIfUseWrappedInAsyncCatch(rejectedError);
       throw rejectedError;
     }
     // ... other code
   }
   ```

   - 状態が`fulfilled`の場合、`use`フックは値を返します
   - 状態が`rejected`の場合、`use`フックはエラーをスローします

   状態が`pending`の場合、React は特別な例外オブジェクトである`SuspenseException`をスローし、thenable が解決または拒否されるまでツリーを一時停止します。

   これにより、コンポーネントはデータがある場合にのみレンダリングされ、それ以外の場合はスローされます。

   :::note
   `use`フックは、エラーをキャッチするためにツリーにエラーバウンダリを配置する必要があります。
   :::

:::warning
`use`フックは、手動でプロミスをキャッシュ/メモ化する必要があります。

`React.cache`実験的な API は、これを助けることを目的としています。
:::

### 例

jsonplaceholder の公開 API からユーザーの詳細を取得することを想定します。

これを実現するために、単純なキャッシュを作成して、プロミスをメモ化し、無限レンダリングを避けることができます。そこで、関数用のダミーメモライザーを作成します：

```tsx
// キャッシュには1つのパラメータを使用すると仮定します
// ユーザーIDです。
// React.cacheはこれを解決する一般的なソリューションです。
// 明確にするため、userIdのみを使用します
function createCache(asyncFunc) {
  let cache = {};

  return function exec(...args) {
    let cacheId = args[0];
    let existing = cache[cacheId];
    if (existing) {
      return existing;
    }

    let result = asyncFunc.apply(null, args);
    cache[cacheId] = result;
    return result;
  };
}
```

次に、ダミーエラーバウンダリを作成します：

```tsx
class ErrorBoundary extends React.Component {
  state = { error: null };
  componentDidCatch(error) {
    this.setState((prev) => ({ ...prev, error }));
  }
  render() {
    const { error } = this.state;
    if (error) {
      return (
        <>
          <pre>{error.toString()}</pre>
          <button
            onClick={() => this.setState((prev) => ({ ...prev, error: null }))}
          >
            Reset
          </button>
        </>
      );
    }
    return this.props.children;
  }
}
```

最後に、このコードを利用します：

```tsx
async function fetchUserById(userId) {
  let result = await axios.get(
    `https://jsonplaceholder.typicode.com/users/${userId}`
  );
  return result.data;
}

let getUserDetails = createCache(fetchUserById);

let IDS = [1, 2, 3, 4, 5, 10, 11];

function UserDetails({ id }) {
  let details = React.use(getUserDetails(id));

  return (
    <details open>
      <pre>{JSON.stringify(details, null, 4)}</pre>
    </details>
  );
}
function Example() {
  let [userId, setUserId] = React.useState(IDS[0]);
  return (
    <div className="App">
      {IDS.map((id) => (
        <button
          onClick={() => {
            setUserId(id);
          }}
          key={id}
        >
          {`User ${id}`}
        </button>
      ))}
      <React.Suspense fallback={`Loading user ${userId}`}>
        <UserDetails id={userId} />
      </React.Suspense>
    </div>
  );
}

export default function App() {
  return (
    <ErrorBoundary>
      <Example />
    </ErrorBoundary>
  );
}
```

この[デモ](https://codesandbox.io/s/lucid-curran-x8xxlj?file=/src/App.js)を表示して操作できます：

<iframe src="https://codesandbox.io/embed/lucid-curran-x8xxlj?fontsize=14&hidenavigation=1&theme=dark"
style={{width: "100%", height: "500px", border: 0, borderRadius: 4}}
title="React.use demo"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

## `useCallback`フックの仕組み

`useCallback`フックを使用すると、依存関係が変更されるまで関数参照を保持できます。

### シグネチャ

`useCallback`は以下のように定義されています：

```tsx
function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

直接的には存在しない関数ですが、前述のように[`mountCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2602)と[`updateCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2609)関数があり、同じシグネチャを持ちます：

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

### 実装

#### マウント時

コンポーネントが最初にレンダリングされるときに`useCallback`を使用すると、呼び出しは`mountCallback`によってインターセプトされ、最も簡単なフックです：

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ステップ1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // ステップ3
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ステップ 1**：前述のフックデータ構造をマウントします
- **ステップ 2**：依存関係を定義します。パラメータが省略された場合は`null`を使用します
- **ステップ 3**：コールバックと依存関係をフックの`memoizedState`プロパティに格納します

`useCallback`は渡された値をそのまま返します。通常、インライン関数を直接定義するか、コンポーネント本体内で定義された関数を渡します。

マウント時に`useCallback`は依存関係については関心がありません。単にそれらを後で使用するために格納するだけです。

#### 更新時

更新時、目的は依存関係が変更された場合にのみ新しい関数参照を与えることです。

```tsx
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ステップ1
  // highlight-next-line
  const hook = updateWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  // ステップ3
  // highlight-next-line
  if (nextDeps !== null) {
    const prevDeps: Array<mixed> | null = prevState[1];
    // ステップ4
    // highlight-next-line
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  // ステップ5
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ステップ 1**：フックデータ構造オブジェクトを作成または再利用します
- **ステップ 2**：依存関係配列を推論します。指定されていない場合は`null`を使用します
- **ステップ 3**：依存関係が null でない場合（undefined を指定するとメモ化しないことを意味します）、前の依存関係と比較します
- **ステップ 4**：前の依存関係と次の依存関係を比較し、同じ場合は前の値（`memoizedState`配列の最初の要素）を返します。比較方法は後で説明します
- **ステップ 5**：依存関係が変更されたか、メモ化していない場合、`mountCallback`と同様に`[callback, nextDeps]`をフックの`memoizedState`プロパティに格納します

The [`areHookInputsEqual`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L451)
関数は依存配列を使用するすべてのフックで使用されます。この関数は：

- 前回の依存配列がない場合、常に`false`を返します。これにより React はフックの返り値を再計算します。つまり、依存配列が空（`[]`）の場合、毎回のレンダーで更新されます
- 両方の配列をループし、`Object.is`で個々の値を比較します

## useContext フックの仕組み

[`useContext`フック](https://react.dev/reference/react/useContext)は[React Context](https://medium.com/@mohamedelayadi/react-context-all-you-need-to-know-40de6662b074)の値を読み取り、変更をサブスクライブすることを可能にします。

### シグネチャ

[`useContext`フック](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L713)は次のように定義されます：

```tsx
function readContext<T>(context: ReactContext<T>): T {
  // [Not Native Code]
}
```

ここでパラメータは[`React.createContext` API](https://react.dev/reference/react/createContext)で作成された React Context オブジェクトを指します。

### 実装

`useContext`は[`readContextForConsumer`](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L740)関数を使用します：

```tsx
export function readContext<T>(context: ReactContext<T>): T {
  // ...開発環境用のチェック
  return readContextForConsumer(currentlyRenderingFiber, context);
}
```

`readContextForConsumer`関数は現在の Context 値を取得し、将来の変更をサブスクライブする役割を担います。実装の詳細を見ていきましょう：

```tsx
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  // ステップ1
  // highlight-next-line
  const value = isPrimaryRenderer
    ? context._currentValue
    : context._currentValue2;

  // ステップ2
  // highlight-next-line
  if (lastFullyObservedContext === context) {
    // 既にこのContextを完全に監視している場合は何もしない
    // ステップ3
    // highlight-next-line
  } else {
  }
}
```

- **ステップ 1**: `isPrimaryRenderer`プロパティに基づいて内部の Context 値を決定します。このプロパティはカスタム React レンダラー作成時に設定されます。Primary レンダラーはページ全体をレンダーし、Secondary は他のレンダラーの上で使用されることを意味します。React-DOM の場合、Primary レンダラーとして動作するため`_currentValue`を使用します
- **ステップ 2**: `lastFullyObservedContext`モジュール変数を使用して Context の監視状態をチェックします。この変数は[コードベース全体で未使用](https://github.com/search?q=repo%3Afacebook%2Freact%20lastFullyObservedContext&type=code)のように見えます
- **ステップ 3**: 実際のサブスクリプション処理が行われる部分（後述）

### Context サブスクリプションの仕組み

Context のサブスクリプションは`fiber.dependencies`プロパティにリンクリスト形式で保存されます：

```tsx
// 簡略化版
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  const value = context._currentValue;

  const contextItem = {
    context: context as ReactContext<any>,
    memoizedValue: value,
    next: null,
  };
}
```

コンポーネントで初めて`useContext`が呼ばれる場合、以下のオブジェクトを`dependencies`として追加します：

```tsx
// 簡略化版

// updateFunctionComponentなどコンポーネント更新時に
// prepareToReadContext関数でlastContextDependency変数をリセット
if (lastContextDependency === null) {
  lastContextDependency = contextItem;
  // consumerは現在処理中のfiber
  consumer.dependencies = {
    lanes: NoLanes,
    firstContext: contextItem,
  };
}
```

既存の依存関係がある場合、context アイテムを前のアイテムの`next`プロパティに追加します：

```tsx
if (lastContextDependency === null) {
  // ...
} else {
  lastContextDependency = lastContextDependency.next = contextItem;
}
```

And that's it!

### 更新処理

`ContextProvider`をレンダリングするコンポーネントが更新されると、React は`value`プロパティをチェックします。値が変更された場合、変更を伝播します。

このセクションの詳細は、`ContextProvider`のレンダリングの仕組みで説明されます。

:::note
`use`フックと同様に、`useContext`はレンダー中に条件付きで呼び出すことが可能です。

ただし、他のフック内やレンダーフェーズ外で呼び出すことはできません。現在レンダリング中の fiber が必要なため、サブスクリプションを実行できないからです。
:::

## useEffect フックの仕組み

[`useEffect`フック](https://react.dev/reference/react/useEffect)はコンポーネントに passive effects を登録することを可能にします。

Passive effects はレンダーの commit フェーズの最後の部分で実行されます。`SyncLane`の場合は同期的に、その他の lane の場合は非同期に実行されます。

公式ドキュメントより：

> useEffect はコンポーネントを外部システムと同期させる React フックです

これは、ブラウザ API（フォーカス、リサイズ、ブラーなど）や外部ストアとの同期にのみ使用すべきであることを意味します。

### シグネチャ

`useEffect`フックは以下のように定義されます：

```tsx
function useEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

パラメータ：

- `create`: effect 作成関数（パラメータなし、クリーンアップ関数を返すか void）
- `deps`: 依存配列（省略時は毎回のレンダー後に実行）

:::note
レンダーフェーズ中に状態更新が発生しても、effect は 2 回実行されません。effect は commit フェーズで実行されます。
:::

### マウント時の実装

通常のフックと同様、`mountWorkInProgressHook()`を使用します。`mountEffect`は`mountEffectImpl`関数を呼び出します。

:::note
`mountEffectImpl`は他の effect フック（useLayoutEffect、useInsertionEffect など）からも呼び出されます。
:::

```tsx
function mountEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  mountEffectImpl(
    PassiveEffect | PassiveStaticEffect,
    HookPassive,
    create,
    deps
  );
}
```

`mountEffectImpl`のシグネチャを確認しましょう：

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- `fiberFlags`: effect を使用するコンポーネントに追加されるフラグ
- `hookFlags`: [effect 自体を定義するフラグ](https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/react-reconciler/src/ReactHookEffectTags.js#L10)。可能な値は`Insertion`、`Layout`、`Passive`。`useEffect`では`Passive`が使用されます
- `create`: effect 関数
- `deps`: effect の依存関係

`mountEffectImpl`関数の実装を見てみましょう：

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // ステップ1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // ステップ3
  // highlight-next-line
  currentlyRenderingFiber.flags |= fiberFlags;
  // ステップ4
  // highlight-next-line
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    createEffectInstance(),
    nextDeps
  );
}
```

- **ステップ 1**: フックデータ構造をマウントします
- **ステップ 2**: 依存関係を定義します。パラメータが省略された場合は`null`を使用します
- **ステップ 3**: 受け取った fiberFlags を現在レンダリング中の fiber に追加します。`useEffect`の場合、`PassiveEffect | PassiveStaticEffect`（執筆時点では自然数`8390656`）が使用されます
- **ステップ 4**: フックの`memoizedState`値として`pushEffect`の結果を保存します

[`createEffectInstance`関数](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2236)は`{ destroy: undefined }`オブジェクトを返します。これは effect のクリーンアップ関数（存在する場合）を保存するために使用されます

最後に[`pushEffect`関数](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2202)を見てみましょう：

```tsx
function pushEffect(
  tag: HookFlags, // useEffect: Passive
  create: () => (() => void) | void,
  inst: EffectInstance, // { destroy: undefined }
  deps: Array<mixed> | null
): Effect {
  // [Not Native Code]
}
```

#### effect オブジェクトの作成

このオブジェクトはレンダーごとに各 effect 用に作成され、必要な情報を保持します：

```tsx
const effect: Effect = {
  tag, // フックフラグ
  create, // 提供されたeffect関数
  inst, // { destroy: undefined }
  deps, // 依存関係またはnull
  // 循環参照
  next: null, // 後で設定されます
};
```

#### effect を関数コンポーネントの update queue にリンク

次に、React は`currentlyRenderingFiber.updateQueue`プロパティを参照します。null の場合、初期化します：

```tsx
let componentUpdateQueue: null | FunctionComponentUpdateQueue =
  currentlyRenderingFiber.updateQueue;
if (componentUpdateQueue === null) {
  componentUpdateQueue = createFunctionComponentUpdateQueue();
  currentlyRenderingFiber.updateQueue = componentUpdateQueue;
  // 循環参照を作成（コミット時に分解されます）
  componentUpdateQueue.lastEffect = effect.next = effect;
}
```

`createFunctionComponentUpdateQueue`で作成される update queue は以下のようになります：

```tsx
const updateQueue = {
  lastEffect: null,
  events: null,
  stores: null,
};

// memoCache機能が有効な場合、nullで初期化されたmemoCacheプロパティが追加されます
```

これは循環リンクリストとして使用されます。lastEffect を保存すると、その`next`プロパティはリストの最初の effect を指すようになります。

コンポーネントの`updateQueue`が既に初期化されている場合（このレンダーで以前に effect を呼び出したか、他のフックが初期化した場合）、React は`lastEffect`プロパティを取得し：

- `null`の場合（updateQueue が effect 以外のイベントやストアで初期化された可能性あり）、以前と同じ処理を行います：`effect`オブジェクトと自身の循環参照を作成し、キューの`lastEffect`プロパティに保存します。
  ```tsx
  const lastEffect = componentUpdateQueue.lastEffect;
  if (lastEffect === null) {
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    // 次の処理を見てみましょう
  }
  ```
- `null`でない場合、このレンダーパスで以前に effect フックを呼び出したことを意味し、以下のコードを実行します：
  ```tsx
  const firstEffect = lastEffect.next;
  lastEffect.next = effect;
  effect.next = firstEffect;
  componentUpdateQueue.lastEffect = effect;
  ```
  混乱しないように、コードを分解してみましょう：
  - まずリストの最初の effect を参照します（循環リンクリストのため、最初の要素は最後の要素の`next`です）
  - 新しい effect を前の`lastEffect`の`next`として追加します（これが新しい最後の要素になります）
  - 新しい effect（新しい最後の要素）は`next`プロパティで`firstEffect`を指すようになります
  - 最後に、新しい effect をコンポーネントの`updateQueue`リストの lastEffect としてマークします

最終的に、`pushEffect`関数は新しく作成された effect オブジェクトを返し、`hook.memoizedState`に保存します。

### Implementation on update

### 更新時の実装

更新時、`useEffect`は`HooksDispatcherOnUpdate`ディスパッチャーから[`updateEffect`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2407)を呼び出し、[`updateEffectImpl`関数](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2348)に委譲します。

:::tip
これが useEffect の動作原理です。effect 関数は commit フェーズで実行されます。レンダー中は関連情報を保存するだけです。

各タイプの effect の実行タイミングについて詳しくは、[`how commit works`セクション](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)を参照してください。
:::

## How useImperativeHandle works

[`useImperativeHandle`フック](https://react.dev/reference/react/useImperativeHandle)は公式ドキュメントで次のように定義されています：

> useImperativeHandle は、ref として公開されるハンドルをカスタマイズできる React フックです

具体的には、カスタムコンポーネントが公開する ref（ハンドル）をオーバーライドできます。例えば、カスタムボタンに`sayHiTo(name)`関数を追加してアラートを表示する場合などに使用します。

### シグネチャ

`useImperativeHandle`は以下のように定義されます：

```tsx
function mountImperativeHandle<T>(
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void,
  create: () => T,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- **ref**: `useRef`または`createRef`で作成された ref オブジェクト、または ref コールバック
- **create**: 新しい ref ハンドルを返す関数
- **deps**: フックの依存関係。依存関係が変更されると create 関数が再呼び出しされます

### マウント時の実装

`useImperativeHandle`を使用するコンポーネントが初めてレンダリングされるとき、[`mountImperativeHandle`関数](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2533)が呼び出されます：

```tsx
// step 1
// highlight-next-line
const effectDeps =
  deps !== null && deps !== undefined ? deps.concat([ref]) : null;
// step 2
// highlight-next-line
mountEffectImpl(
  UpdateEffect | LayoutStaticEffect,
  HookLayout,
  imperativeHandleEffect.bind(null, create, ref),
  effectDeps
);
```

- **ステップ 1**: 実際のフック依存関係を計算します。提供された依存関係に ref オブジェクト自体を追加します。ref を配列に追加せず、開発者が手動で追加するべきと仮定することも可能ですが、後方互換性が失われます
- **ステップ 2**: 2 番目のステップは effect をマウントすることです（驚きですね！😳）

その通りです。`useImperativeHandle`は特別な layout effect を挿入します。この effect の`create`関数は[`imperativeHandleEffect`関数](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2503)です

:::tip
コミットフェーズ中、React は`Layout`フェーズで ref をアタッチします。これが全体の処理が layout effect として使用される理由です
:::

### 更新時の実装

更新時、`useImperativeHandle`はマウント時と同様に依存関係を計算し、`UpdateEffect`を fiber フラグとして`updateEffectImpl`を呼び出します

これが実際の処理内容です。

### imperativeHandleEffect 関数

#### シグネチャ

```tsx
function imperativeHandleEffect<T>(
  create: () => T,
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void
): void | (() => void) {
  // [Not Native Code]
}
```

#### Implementation

渡された ref が ref オブジェクトか ref コールバックかに基づいて処理を実行し、いずれの場合も渡された`create`関数を呼び出し、layout effect 用のクリーンアップ関数を返します：

```tsx
if (typeof ref === "function") {
  // step 1
  // highlight-next-line
  const refCallback = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refCallback(inst);
  // step 4
  // highlight-next-line
  return () => {
    refCallback(null);
  };
}
```

- **Step 1**: 渡された ref コールバックの参照を保持
- **Step 2**: useImperativeHandle の create 関数を呼び出し、新しい ref ハンドルを生成
- **Step 3**: 生成されたハンドルで ref コールバックを呼び出し
- **Step 4**: ref コールバックを null で再度呼び出すクリーンアップ関数を返却

別のケースとして、渡された`ref`が ref オブジェクトの場合、`imperativeHandleEffect`は以下を実行します：

```tsx
// 元々はelse if節
if (ref !== null && ref !== undefined) {
  // step 1
  // highlight-next-line
  const refObject = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refObject.current = inst;
  // step 4
  // highlight-next-line
  return () => {
    refObject.current = null;
  };
}
```

- **Step 1**: 渡された ref オブジェクトの参照を保持
- **Step 2**: useImperativeHandle の create 関数を呼び出し、新しい ref ハンドルを生成
- **Step 3**: 生成された ref ハンドルを ref オブジェクトの`current`プロパティに割り当て
- **Step 4**: `current`プロパティを null にリセットする layout effect のクリーンアップ関数を返却

これで完了です！

:::note
前述の通り、`imperativeHandleEffect`はコミットフェーズの layout effect イテレーション中に呼び出されます。レンダー中に即座に呼び出されることはありません。
:::

## How useInsertionEffect works

[`useInsertionEffect`フック](https://react.dev/reference/react/useInsertionEffect)は公式ドキュメントで次のように定義されています：

> すべての layout effects が発火する前に DOM 要素を挿入できるようにします

公式ドキュメントに記載されている通り、css-in-js ライブラリの作者のみが使用すべきフックです。それ以外の場合は`useLayoutEffect`または`useEffect`を使用してください。

### シグネチャ

他の effects と同様、`useInsertionEffect`は以下のように定義されます：

```tsx
function useInsertionEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### 実装

`useInsertionEffect`の実装は[`useEffect`と同じ](#how-useeffect-works)です。唯一の違いは、マウント時と更新時に`mountEffectImpl`と`updateEffectImpl`に渡される`flags`です：

- マウント時：React は fiber flags として`UpdateEffect`、hook flags として`HookInsertion`を渡します
- 更新時：React は fiber flags として`UpdateEffect`、hook flags として`HookInsertion`を渡します

これだけです！すべての effects は flags の違いのみで区別されます。

## How useLayoutEffect works

[`useLayoutEffect`フック](https://react.dev/reference/react/useLayoutEffect)は公式ドキュメントで次のように定義されています：

> ブラウザが画面を再描画する前に発火する useEffect のバージョンです

ただし、useEffect との比較においてこれは完全に正確ではありません。[`how commit works`セクション](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)で詳細が明らかになります。

`useLayoutEffect`は、DOM 要素の変更後に同期的に実行される effect を登録できます。

その同期的な性質により、ブラウザのメインスレッドをブロックし、新しい UI の部分的なペイントを防ぎます。これが「useLayoutEffect はブラウザのペイント前に実行される」と言われる理由です。

`useLayoutEffect`は`ClassComponent`のライフサイクルメソッド（`componentDidMount`と`componentDidUpdate`)と同じタイミングで実行されます。

### シグネチャ

他の effects と同様、`useInsertionEffect`は以下のように定義されます：

```tsx
function useLayoutEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### 実装

`useLayoutEffect`の実装は[`useEffect`と同じ](#how-useeffect-works)です。唯一の違いは、マウント時と更新時に`mountEffectImpl`と`updateEffectImpl`に渡される`flags`です：

- マウント時：React は fiber flags として`UpdateEffect | LayoutStaticEffect`、hook flags として`HookLayout`を渡します
- 更新時：React は fiber flags として`UpdateEffect`、hook flags として`HookLayout`を渡します

これだけです！すべての effects は flags の違いのみで区別されます。

## useMemo の仕組み

[`useMemo`フック](https://react.dev/reference/react/useMemo)は依存関係が変更されるまで値をキャッシュします。

### シグネチャ

`useMemo`は以下のように定義されます：

```tsx
function useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

パラメータ：

- **`nextCreate`**: キャッシュする値を生成する関数
- **`deps`**: 依存関係

### マウント時の実装

マウント時、`useMemo`は[`mountMemo`を呼び出します](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2623)。実装は以下の通り：

```tsx
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null
): T {
  // ステップ1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // ステップ3
  // highlight-next-line
  const nextValue = nextCreate();
  // ステップ4
  // highlight-next-line
  hook.memoizedState = [nextValue, nextDeps];
  // ステップ5
  // highlight-next-line
  return nextValue;
}
```

- **ステップ 1**: マウント時に hook オブジェクトを作成
- **ステップ 2**: 提供された依存関係または`null`を使用
- **ステップ 3**: 初期メモ値を計算
- **ステップ 4**: `[nextvalue, nextDeps]`を hook の`memoizedState`に保存
- **ステップ 5**: キャッシュされた値を返却

:::note
開発モードで StrictMode が有効な場合、React は`nextCreate`を 2 回呼び出します：

```tsx
// renderWithHooks関数で初期化
if (shouldDoubleInvokeUserFnsInHooksDEV) {
  nextCreate();
}
```

:::

### Implementation on update

On updates, `useMemo` will [call `updateMemo`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2637)
which is defined as follows:

```tsx
function updateMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null
): T {
  // step 1
  // highlight-next-line
  const hook = updateWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  const prevState = hook.memoizedState;
  // Assume these are defined. If they're not, areHookInputsEqual will warn.
  if (nextDeps !== null) {
    const prevDeps: Array<mixed> | null = prevState[1];
    // step 4
    // highlight-next-line
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    nextCreate();
  }
  // step 5
  // highlight-next-line
  const nextValue = nextCreate();
  // step 6
  // highlight-next-line
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
```

- **Step 1**: create the hook object on update (or reuse from incomplete render)
- **Step 2**: calculate the deps to use, either the provided ones or `null`
- **Step 3**: reference the previous rendered value (even if the render was
  incomplete, use the rendered value, because it matters)
- **Step 4**: when dependencies are the same, the previously cached value is
  returned
- **Step 5**: compute again the cached value using the passed `nextCreate` memo
  function
- **Step 6**: store the `[nextValue, nextDeps]` along with the deps in the
  `memoizedState` of the hook and return the new cached value.

And that's it! `useMemo` is similar to `useCallback` in terms of implementation
and complexity, the difference is that `useMemo` calls your function and
`useCallback` will give it back to you.

## How useReducer works

The [`useReducer` hook](https://react.dev/reference/react/useReducer) allows
you to add a reducer to your component.

A `reducer` is a function that accepts two arguments: the current `value` and
an `action` to apply on that value, then return a `new value`. Like this:

```tsx
function reducer(prevValue, action) {
  // perform some logic based on the action and the value
  // ...
  // then return a new value
}
```

### Signature

The `useReducer` hook is defined as follows:

```tsx
function useReducer<S, I, A>(
  reducer: (state: S, action: A) => S,
  initialArg: I,
  init?: (initialValue: I) => S
): [S, Dispatch<A>] {
  // [Not Native Code]
}
```

Where the arguments are:

- **reducer**: The reducer function
- **initialArg**: The initial value
- **init**: An optional initializer function that receives the `initialArg`

And it returns an array containing two elements:

- **state**: the state value
- **dispatch**: a function that accepts the `action` to pass to our reducer.

### Implementation on mount

When a component using `useReducer` mounts for the first time, the
[`mountReducer` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1177)
gets called. Let's break into it:

1. Mount the work in progress hook:

   As you would expect, the first thing to do is this one. If you don't
   understand why, you probably did skip this whole section 😑

   ```tsx
   const hook = mountWorkInProgressHook();
   ```

2. Compute the initial state:
   The initial state computation depends on whether you provided the third
   parameter:

   ```tsx
   let initialState;
   if (init !== undefined) {
     initialState = init(initialArg);
   } else {
     initialState = initialArg as S;
   }
   ```

   It is either the `initialArg` or the result of your function about it.

3. Assign the hook `memoizedState` property

   This unveils what this hook stores in the `memoizedState` property. But not
   it also populates the `baseState` property at this stage.

   ```tsx
   hook.memoizedState = hook.baseState = initialState;
   ```

4. Create an UpdateQueue object and assign it

   The update queue is an object referring to the internal state of `useReducer`,
   we won't deal with it here, but mostly when the component is updating or when
   React is scheduling/processing state updates. But it is important to take a
   look at its shape and referenced things.

   At first, it only references the initially given `reducer` and the computed
   `initialState`

   ```tsx
   const queue: UpdateQueue<S, A> = {
     pending: null,
     lanes: NoLanes,
     dispatch: null,
     lastRenderedReducer: reducer,
     lastRenderedState: initialState,
   };
   hook.queue = queue;
   ```

5. Create the dispatch function and return
   ```tsx
   const dispatch: Dispatch<A> = (queue.dispatch = dispatchReducerAction.bind(
     null,
     currentlyRenderingFiber,
     queue
   ));
   return [hook.memoizedState, dispatch];
   ```
   The dispatch function is very important and is defined elsewhere, `mountReducer`
   will just give it two of the three parameters it accepts. Let's break it.

### How `dispatchReducerAction` works

`dispatchReducerAction` is defined as follows:

```tsx
function dispatchReducerAction<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A
): void {
  // [Not Native Code]
}
```

Its job is to tell React to schedule an update on the desired `fiber` and its
`queue` (a component can have several `useReducer`s, the queue holds all the
pending updates to be processed), using the given `action`.

In other terms, this is the `dispatch` function `useReducer` and `useState` give
you.

> So, now, you are reading how the stateSetter works for function components.

The rest of this part would be easier if you've already read
[the `how root.render() works` section.](/how-react-works/docs/react-dom/how.root_render.works#2-request-an-update-lane)

We won't explain again many things to keep this part easy. Scheduling updates
works almost the same.

1. Request an update lane
   ```tsx
   const lane = requestUpdateLane(fiber);
   ```
   The very first step is to infer the `lane` for this upcoming update, for
   example:
   - If your application wasn't rendered through concurrent mode
     (`createRoot().render()`) then the `SyncLane` is used.
   - If a render phase update, then the highest priority lane is used
     (or, the smallest Lane present in the given Lanes number 😉).
   - One of the transition lanes if wrapped in `startTransition`
   - An event priority as seen in [how root render schedule works](/how-react-works/docs/react-dom/how.root_render_schedule.works#implementation-steps)
2. Create an update object
   ```tsx
   const update: Update<S, A> = {
     lane,
     revertLane: NoLane,
     action,
     hasEagerState: false,
     eagerState: null,
     next: null,
   };
   ```
   The update is defined by many properties, but the only two relevant for now
   are the update `lane` and the `action`. React keeps track of them in order to
   be able to play them later.
   Of course, one other important property is `next`.. A linked list again.
3. Enqueue a render phase update when called during render

   ```tsx
   if (isRenderPhaseUpdate(fiber)) {
     enqueueRenderPhaseUpdate(queue, update);
   }
   ```

   A render phase update is detected when the `fiber` is equal to
   `currentlyRenderingFiber` or its alternate.

   When it is the case, React will call the
   [`enqueueRenderPhaseUpdate` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3347)
   which is implemented as follows:

   ```tsx
   function enqueueRenderPhaseUpdate<S, A>(
     queue: UpdateQueue<S, A>,
     update: Update<S, A>
   ): void {
     // step 1
     didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
       true;
     const pending = queue.pending;
     if (pending === null) {
       // step 2
       update.next = update;
     } else {
       // step 3
       update.next = pending.next;
       pending.next = update;
     }
     // step 4
     queue.pending = update;
   }
   ```

   - **Step 1**: Mark as did schedule a render phase update. This variable
     is important for React since it will allow it to render the component
     again before going to other components or committing.
   - **Step 2**: When there is no pending updates in the queue, the update
     will point to itself as `next`
   - **Step 3**: When there are some pending updates, since it is a circular
     linked list (meaning that the `pending` is the last item, and `pending.next`
     is the first), then we will perform a small gymnastic to mark the first
     update as the next of the new update, and the new update the next of the
     first.
   - **Step 4**: Lately, React will mark the new `update` as the `pending`
     of the queue (it is the last update to be performed.)

4. When not called during render, enqueue a concurrent hook update, then
   schedule an update on the fiber, then entangle transitions

   ```tsx
   if (false) {
   } else {
     const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
     if (root !== null) {
       scheduleUpdateOnFiber(root, fiber, lane);
       entangleTransitionUpdate(root, queue, lane);
     }
   }
   ```

   I won't explain this again to keep this section brief, all of this was
   explained [during `how root.render() works`!](/how-react-works/docs/react-dom/how.root_render.works#5-enqueue-the-created-update-to-the-fiber).
   It works the same!

   At the end we will have a microtask scheduled to process the updateQueue
   of the fiber that caused the render.

:::tip
Scheduling updates an efficient process, combined with the fast that react
combine fiber `flags` of children into their parents, it knows for sure
when to start the work and when to stop.

The important things to note:

- React doesn't process the updates on the fly, but add them to the queue and
  schedules the work for later.
- React keeps track of the update details (the queue, the action/value/updater)
  so it can process them later.
- Queuing updates allows React to batch them and render one time rather than many.
  :::

### Implementation on update

<TBD />

## How useRef works

The `[useRef` hook](https://react.dev/reference/react/useRef) gives you a
reference that you can control as you please. You can reference any javascript
value in it.

In the official docs, it is stated that:

> useRef is a React Hook that lets you reference a value that’s not needed for
> rendering.

React tries to push you not to use this ref and base your decisions on it while
the component is rendering. It is okay though to manipulate it outside render.

For example, if you mutate this value during render, React may render several
times and thus write on it multiple times. The easiest way to observe this for
example is by using a ref to count how many times your component rendered. In
development mode and under strict mode, you will all the time get wrong results.
That one reason to get away from it for this kind of usage.

People also often use the ref to detect whether the component is currently
mounting or not, but this is also wrong: since if the component mounted already
then suspended waiting for data while showing a Suspense fallback, the component
stays mounted and thus any decision based on that value will be wrong.

You can also pass this ref object to any HTML element and React will attach the
real DOM element on layout effect. Again, this is yet another reason to get
away from this hook during render and minimize its usage.

Please refer to the official docs to learn more when to use and when not
to use the `useRef` hook.

### Signature

The `useRef` hook is defined as follows:

```tsx
function mountRef<T>(initialValue: T): { current: T } {
  // [Not Native Code]
}
```

### Implementation on mount

When your component using `useRef` renders for the first time, it will call
the [`mountRef` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2257),
which is probably the easiest hook ever:

```tsx
// simplified: dev warning about reading from ref during render were removed
// for clarity
function mountRef<T>(initialValue: T): { current: T } {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const ref = { current: initialValue };
  // step 3
  // highlight-next-line
  hook.memoizedState = ref;
  // step 4
  // highlight-next-line
  return ref;
}
```

- **Step 1**: create the hook object on mount
- **Step 2**: create a javascript object with one `current` property,
  initialized by the `initialValue` received by `useRef`
- **Step 3**: store this object as the `memoizedState` of this hook
- **Step 4**: return the ref object

### Implementation on update

On updates, `useRef` will call the [`updateRef` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2326)
which is very simple and doesn't need any explanations:

```tsx
function updateRef<T>(initialValue: T): { current: T } {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
```

It just creates the hook object while reusing the ref mutable object as is,
and will return the memoized state directly.

## How useState works

The [`useState` hook](https://react.dev/reference/react/useState) allows you to
add a variable to your component that it will cause it to update when its value
changes.

From the Official documentation:

> useState is a React Hook that lets you add a state variable to your component.

State is the only reactive primitive in React for now (promises somehow are
reactive, but under the hood, they call `scheduleUpdateOnFiber` too, and
it's kind hard to work only with them.).

The rest of this section assumes that you've read the `useReducer` section.

### Signature

`useState` is defined as follows:

```tsx
function useState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  // [Not Native Code]
}
```

It accepts one single parameter called the `initialState` which is the initial
state value of a function that will produce it.

### Implementation on mount

Well, we'll have to spoil this already: `useState` is `useReducer` where the
reducer is:

```tsx
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  return typeof action === "function" ? action(state) : action;
}
```

So, if you give `useReducer` this reducer which, if it receives a function, it
will call it with the actual state, or else just take the passed value.
`useReducer` will behave like `useState` as we know it.

```tsx
function useState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  // step 1
  // highlight-next-line
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  // step 2
  // highlight-next-line
  const dispatch: Dispatch<BasicStateAction<S>> = dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    queue
  );
  // step 3
  // highlight-next-line
  queue.dispatch = dispatch;
  return [hook.memoizedState, dispatch];
}
```

- **Step 1**: The first step is where we will call `mountWIPHook` and initialize
  the hook object and `UpdateQueue`.
- **Step 2**: Reference the queue to use it while creating the `dispatch`
  function.
- **Step 3**: Return the `useState` value which is a tuple of the state current
  value and the dispatch function (`setState`).

#### How `mountStateImpl` works

Let's take a look at how this function is implemented:

```tsx
function mountStateImpl<S>(initialState: (() => S) | S): Hook {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  if (typeof initialState === 'function') {
    initialState = initialState();
  }
  // step 3
  // highlight-next-line
  hook.memoizedState = hook.baseState = initialState;
  // step 4
  // highlight-next-line
  const queue: UpdateQueue<S, BasicStateAction<S>> = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  };
  hook.queue = queue;
  return hook;
}
```

- **Step 1**: Mount the hook object inside the linked list of hooks.
- **Step 2**: Call the initializer function if `initialState` is a function.
- **Step 3**: Mark the hook's `memoizedState` as the initial value. Same for
  `baseState`.
- **Step 4**: Create the update queue object and assign it to the hook's queue.

:::tip
And that's it! useState is useReducer. Take a look at [the commit where hooks](https://github.com/facebook/react/commit/7bee9fbdd49aa5b9365a94b0ddf6db04bc1bf51c)
were introduced back to 2018. It was literally:

```tsx
export function useState<S>(
  initialState: S | (() => S)
): [S, Dispatch<S, BasicStateAction<S>>] {
  return useReducer(basicStateReducer, initialState);
}
```

:::

### Implementation on update

On updates, `updateState` will delegate the work entirely to `updateReducer`,
and that's it!

```tsx
function updateState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  return updateReducer(basicStateReducer, initialState);
}
```

## How useDebugValue works

This is an empty hook that only works in development mode.

The implementation of `useDebugValue` is empty as [shown in `mountDebugValue`:](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2594)

```tsx
function mountDebugValue<T>(value: T, formatterFn?: (value: T) => mixed): void {
  // This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

const updateDebugValue = mountDebugValue;
```

When taking a look at [the `ReactDebugHooks.js` file](https://github.com/facebook/react/blob/aec521a96d3f1bebc2ba38553d14f4989c6e88e0/packages/react-debug-tools/src/ReactDebugHooks.js#L238)
we can see that this hook's implementation only pushes the logged value
to a module level array that collects information to be shown in the React
devtools, which is out of scope of this article and won't be an easy thing
to document for now.

## How useDeferredValue works

<TBD />

## How useTransition works

<TBD />

## How useSyncExternalStore works

<TBD />

## How useId works

<TBD />

## Annex

This is a table for all the internal stored value for all hooks:

| Hook                   | `memoizedState`    | Comment(s)                                                                                                                         |
| ---------------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| `use`                  | `N/A`              | `use` doesn't obey the rules of hooks and does not use the internal data structure                                                 |
| `useCallback`          | `[callback, deps]` | `useCallback` saves the passed callback and dependencies                                                                           |
| `useContext`           | `N/A`              | `useContext` doesn't rely on hooks call order, it is stored in the `fiber.dependencies` property                                   |
| `useEffect`            | `effect`           | `useEffect` saves the effect object created by `pushEffect` which references the effect function, the deps and so on               |
| `useImperativeHandle`  | `effect`           | `useImperativeHandle` calls is a `useLayoutEffect` under the hood                                                                  |
| `useLayoutEffect`      | `effect`           | `useLayoutEffect` saves the effect object created by `pushEffect` which references the effect function, the deps and so on         |
| `useInsertionEffect`   | `effect`           | `useInsertionEffect` saves the effect object created by `pushEffect` which references the effect function, the deps and so on      |
| `useMemo`              | `[value, deps]`    | `useMemo` saves the resulting cached value and the dependencies                                                                    |
| `useReducer`           | `state`            | `useReducer` saves only the state value in memoizedState, dispatch is stored in the queue                                          |
| `useRef`               | `{current: value}` | `useRef` saves the `{current: value}` as memoized state                                                                            |
| `useState`             | `state`            | `useState` is `useReducer` with a special reducer, it saves only the state value in memoizedState, dispatch is stored in the queue |
| `useDebugValue`        | `N/A`              | `useDebugValue` is an empty hook that is inject by the devtools                                                                    |
| `useDeferredValue`     | `TBD`              |                                                                                                                                    |
| `useTransition`        | `TBD`              |                                                                                                                                    |
| `useSyncExternalStore` | `TBD`              |                                                                                                                                    |
| `useId`                | `TBD`              |                                                                                                                                    |
