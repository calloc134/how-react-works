---
sidebar_position: 10
---

# フックの仕組み

## はじめに

React v16.8.0 で導入された[フック](https://react.dev/reference/react/hooks)は、React アプリの書き方を変革しました。フック以前は、ステートやライフサイクルロジックが必要な場合、クラスコンポーネントを使用する必要がありました。フックの登場により、ファンクションコンポーネントが React アプリ開発のデファクトスタンダードとなりました。

フックは多くのことをシンプルにしました（クラスコンポーネントより優れていると言っているわけではありません）。コンポーネントの推論や扱いを容易にし、`this`の扱いから解放されるなどの利点があります。

公式ドキュメントでフック自体の説明は十分されているため、ここでは React 内部での実装方法に焦点を当てます。

## コンテキスト

前章の「ファンクションコンポーネントのレンダリング方法」で、コンポーネントが初回マウント時か更新時かに基づいて`Dispatcher`を設定することを説明しました。この Dispatcher の正体を解明しましょう。

## `ReactCurrentDispatcher`

[`renderWithHooks`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556)関数内で、`ReactCurrentDispatcher.current`を設定します。これは React のすべてのフック実装を含むプレーンな JavaScript オブジェクトです。

Dispatcher オブジェクトの目的は、フックの使用を制限することにあります：

- レンダーフェーズ外でのフック使用を禁止（手動でファンクションコンポーネントを呼び出した場合など）
- マウント時と更新時で異なるフックの挙動（マウント時はフックの位置確保と初期化、更新時は更新ロジックの実行）

Dispatcher には React のフックに対応するプロパティが含まれます：

```tsx
export const AllDispatchers: Dispatcher = {
  readContext,

  use,
  useCallback: hook,
  useContext: hook,
  useEffect: hook,
  useImperativeHandle: hook,
  useInsertionEffect: hook,
  useLayoutEffect: hook,
  useMemo: hook,
  useReducer: hook,
  useRef: hook,
  useState: hook,
  useDebugValue: hook,
  useDeferredValue: hook,
  useTransition: hook,
  useSyncExternalStore: hook,
  useId: hook,
};
```

Dispatcher にはいくつかの種類がありますが、主に 4 つを解説します：

- `ContextOnlyDispatcher`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408)
  はレンダーフェーズ外でのフック使用を防ぎます。いわゆる「Invalid hook call」[エラー](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440)をスローします
- `HooksDispatcherOnMount`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446)
  はコンポーネントが初回マウントされる際のフック実装を含みます
- `HooksDispatcherOnUpdate`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484)
  はコンポーネントが更新される際のフック実装を含みます
- `HooksDispatcherOnRerender`: [この Dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522)
  は以下の場合の再レンダー時に使用されます：
  - レンダーフェーズ中に状態更新が発生した場合
  - 開発モードでコンポーネントが 2 回レンダリングされる場合

## フックのモデリング

各ファンクションコンポーネントはサポートされているフックを呼び出せます。すべてのフック呼び出しは`renderWithHooks`関数内で発生します（再レンダー用のフックは`renderWithHooksAgain`関数から呼び出される例外を除く）。

フックは[関連する`Fiber`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965)の`memoizedState`プロパティに保存されます。

フックは React 内部で以下のプロパティを持つプレーンオブジェクトとして保存されます：

```tsx
const hook: Hook = {
  memoizedState: null,

  baseState: null,
  baseQueue: null,
  queue: null,

  next: null,
};
```

各プロパティの役割：

- `memoizedState`: フックの「ステート」（または値）を保持
- `baseState`: ステートフックが初期値を保存するために使用
- `baseQueue`:
- `queue`: ステートフックが様々な情報を保存するための UpdateQueue オブジェクト
- `next`: 次のフックを指す

`next`プロパティがコンポーネントで使用する次のフックを参照することから、フックは前述のデータ構造のリンクリストとしてモデリングされています。

各フックはこれらのプロパティに何を保存するかについて独自の仕様を持ち、明らかにすべてのプロパティを使用しないフックもあります。

このデータ構造にはフックの種類に関する情報が含まれていないことに注目してください。フックは呼び出し順序に依存し、常に保存される必要があります。

![fiber and hook](imgs/10.fiber_and_hook.png)

Dan Abramov はこの設計選択について[優れたブログ記事](https://overreacted.io/why-do-hooks-rely-on-call-order/)を書いています。

### フックの例

以下のコンポーネントをレンダリングすると仮定します：

```tsx
function MyFunctionComponent(props) {
  const [count, setCount] = React.useState(0);
  // デモ用のため実際には推奨されません
  const isMounted = React.useRef(false);
  // デモ用のため実際には推奨されません
  const mountDate = React.useMemo(() => Date.now(), []);

  React.useEffect(() => {
    function handler() {
      console.log("window is focused");
    }

    window.addEventListener("focus", handler);
    return () => window.removeEventListener("focus", handler);
  }, []);

  return <span>Count is {count}</span>;
}
```

このコンポーネントをレンダリングすると、`FunctionComponent`タグの`Fiber`が生成され、以下のようなフックのリンクリストが作成されます：

```tsx
let memoizedState = {
  // useState
  memoizedState: 0,
  baseState: 0,
  baseQueue: null,
  queue: {
    pending: null,
    lanes: 0,
    lastRenderedState: 0,
  },
  next: {
    // useRef
    memoizedState: {
      current: false,
    },
    baseState: null,
    baseQueue: null,
    queue: null,
    next: {
      // useMemo
      memoizedState: [1700218172414, []],
      baseState: null,
      baseQueue: null,
      queue: null,
      next: {
        // useEffect
        memoizedState: {
          tag: 9,
          inst: {},
          deps: [],
          next: "the same effect .. removed for clarity",
        },
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      },
    },
  },
};
```

## マウント時のフックの仕組み

マウント時のフックの目的は、リンクリストのフックの位置を確保することです。

そのため、すべてのフック実装はマウント時に以下の処理を最初に行います：

```tsx
const hook = mountWorkInProgressHook();
```

`mountWorkInProgressHook`関数は前述のデータ構造を作成し、それを`currentlyRenderingFiber`の`memoizedState`プロパティに設定します。

### `mountWorkInProgressHook`の実装

マウント中のフック関数は以下のように実装されています：

```tsx
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // これはリストの最初のフックです
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // リストの末尾に追加
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

- 最初にフックオブジェクトを作成します
- その後、リストの最初のフックである場合、それを`currentlyRenderingFiber`の`memoizedState`にアタッチし、`workInProgressHook`にも設定します
- それ以外の場合、`workInProgressHook`の`next`プロパティにアタッチします

以上です！

フックによっては、他の処理も行われますが、それぞれのサポートされるフックについて別々に説明します。

## 更新時のフックの仕組み

コンポーネントが更新される（初回レンダリングではない）場合、各サポートされるフック呼び出しは以下の式で始まり、その後に特定の処理が続きます。

```tsx
const hook = updateWorkInProgressHook();
```

[`updateWorkInProgressHook`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973)
はマウントよりも複雑ですが、目的は次の`workInProgressHook`を検出することです。これは更新と再レンダリングの両方に使用され、前回のレンダリングから`current`フックオブジェクトをクローンするか、`work-in-progress`を再利用するかを想定しています。

この関数の最初の部分では、現在のレンダリングされたフックの値を検出します。`currentHook`モジュール変数が null の場合、`current`レンダリング済みファイバーの`memoizedState`プロパティをチェックします。それ以外の場合は、その`next`プロパティを取得します：

```tsx
// モジュールレベルで：
let currentHook: null | Hook = null;

// updateWorkInProgressHook内で：

let nextCurrentHook: null | Hook;
if (currentHook === null) {
  // 現在のレンダリング済みファイバー
  const current = currentlyRenderingFiber.alternate;

  // すでにマウント済みの場合
  if (current !== null) {
    nextCurrentHook = current.memoizedState;
  } else {
    // 初回マウントの場合
    nextCurrentHook = null;
  }
} else {
  nextCurrentHook = currentHook.next;
}
```

これで、現在のレンダリング済み（ペイント済み）フックの値を検出したので、React は次にその代替（レンダリング中のもの）を検出します：

```tsx
// モジュールレベルで：
let workInProgressHook: null | Hook = null;

// updateWorkInProgressHook内で：
let nextWorkInProgressHook: null | Hook;

// リストの最初のフックの場合、レンダリング中のファイバーから取得
if (workInProgressHook === null) {
  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
} else {
  // それ以外の場合、次のフック
  nextWorkInProgressHook = workInProgressHook.next;
}
```

コンポーネントを更新する際、memoizedState プロパティはリセットされ、null に設定されます。

これで、現在のペイント済みフックの値と、レンダリング中のものを持つことができました。

`nextWorkInProgressHook`がある場合、これはすでにレンダリングを開始していて、コミットやレンダリングの終了なしに再度レンダリングしていることを意味し、そのまま再利用します：

```tsx
if (nextWorkInProgressHook !== null) {
  // すでにワークインプログレスがあります。再利用します。
  workInProgressHook = nextWorkInProgressHook;
  nextWorkInProgressHook = workInProgressHook.next;

  currentHook = nextCurrentHook;
}
```

それ以外の場合、`nextCurrentHook`が null の場合、前回のレンダリングよりもフックを多くレンダリングしていることを意味し、フックの規則に反することになり、React はエラーをスローします。
`nextCurrentHook`が null でない場合、前回のレンダリングのフックをクローンして基にする必要があります：

```tsx
// Reactのコード

if (nextWorkInProgressHook !== null) {
  // 前のコード
} else {
  if (nextCurrentHook === null) {
    const currentFiber = currentlyRenderingFiber.alternate;
    if (currentFiber === null) {
      // これは初回レンダリングです。このブランチは、コンポーネントが一時停止し、再開してから追加のフックをレンダリングするときに到達します。
      // このブランチに到達することはありません。最初にマウントディスパッチャーに切り替える必要があります。
      throw new Error(
        "Update hook called on initial render. This is likely a bug in React. Please file an issue."
      );
    } else {
      // これは更新です。常に現在のフックがあるはずです。
      throw new Error("Rendered more hooks than during the previous render.");
    }
  }

  currentHook = nextCurrentHook;

  // 現在のペイント済みフックからクローン
  const newHook: Hook = {
    memoizedState: currentHook.memoizedState,

    baseState: currentHook.baseState,
    baseQueue: currentHook.baseQueue,
    queue: currentHook.queue,

    next: null,
  };

  if (workInProgressHook === null) {
    // これはリストの最初のフックです。
    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
  } else {
    // リストの末尾に追加
    workInProgressHook = workInProgressHook.next = newHook;
  }
}
```

## 再レンダリング時のフックの仕組み

コンポーネントの再レンダリングという用語は、React コードベース内ではレンダーフェーズの更新をスケジュールしたか、開発モードで再生していることを意味します。

`HooksDispatcherOnRerender`ディスパッチャーを見ると、`useReducer: rerenderReducer`, `useState: rerenderState`, `useDeferredValue: rerenderDeferredValue`, `useTransition: rerenderTransition`以外は`HooksDispatcherOnUpdate`と同じであることがわかります。

このディスパッチャーは[`renderWithHooksAgain`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771)関数から設定されます。Andrew のコメントをコピーします：

```tsx
// これは別のレンダーパスを実行するためのものです。レンダーフェーズの更新が呼び出されたとき、または開発モードでコンポーネントがレンダーフェーズで2回レンダリングされるときに使用されます。
//
// 前回のパスの状態は可能な限り再利用されます。そのため、すでに処理された状態更新は再度処理されず、メモ化された関数（`useMemo`）は再度呼び出されません。
//
// レンダーフェーズの更新がスケジュールされ続ける限り、ループでレンダリングを続けます。無限ループを防ぐためにカウンターを使用します。
```

## 各フックの仕組み

ディスパッチャーの存在順に従って、各フックを説明します。

import TBD from "./components/TBDBanner"

## `use`フックの仕組み

`use`フックは、データを待っている間にスローされる`throw promise`パターンを置き換える新しいフックです。

`throw promise`は長くから存在していましたが、公式ではなく、このフックは公式の代替として導入されました。

### シグネチャ

`use`フックは[ここで定義されています](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1093)。

```tsx
function use<T>(usable: Usable<T>): T {
  // [Not Native Code]
}
```

Promise または Context 型のオブジェクトを受け入れます。

:::tip
`use`フックは`mountWorkInProgressHook`と`updateWIPHook`に依存しないため、条件付きで呼び出すことができ、フックの規則に従わなくなります。
:::

### 実装

前述のように、`use`は`thenabled`と`Context`の両方を受け入れます：

#### Context

`use`に渡されたオブジェクトが React の`Context`である場合、`readContext`関数に処理を委譲します。これは`useContext`セクションで説明します。

```tsx
if (
  usable.$$typeof === REACT_CONTEXT_TYPE ||
  usable.$$typeof === REACT_SERVER_CONTEXT_TYPE
) {
  const context: ReactContext<T> = usable;
  return readContext(context);
}
```

そのため、`use`を使用すると条件付きでコンテキストにサブスクライブでき、フックの規則を回避できます 🤯

#### Thenable

Thenable オブジェクトが提供された場合、React は[内部の`useThenable`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L1066)関数を呼び出します：

```tsx
function use<T>(usable: Usable<T>): T {
  if (usable !== null && typeof usable === "object") {
    if (typeof usable.then === "function") {
      const thenable: Thenable<T> = usable;
      return useThenable(thenable);
    }
    // ... other code
  }

  throw new Error("An unsupported type was passed to use(): " + String(usable));
}
```

`useThenable`関数が`use`フックの仕事の背後にあることが明らかになりました。

初期化と thenable 状態のインクリメント（これについては説明しません）の後、`useThenable`は[`trackUsedThenable`](https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberThenable.js#L69)を呼び出し、これがすべての仕事を行います。

```tsx
function useThenable<T>(thenable: Thenable<T>): T {
  // このファイバー内でthenableの位置を追跡します。
  const index = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    // createThenableStateはプレーンなJavaScript配列を返します
    thenableState = createThenableState();
  }
  // highlight-next-line
  const result = trackUsedThenable(thenableState, thenable, index);
  // ... other code
  return result;
}
```

それでは`trackUsedThenable`について説明します：

1. パート 1：thenable を配列に追加する

   ソフィーのコメントに注意してください。同じ位置に thenable があった場合、技術的には同じ値を指すはずですので、前者を再利用します。この設計選択について聞かれたら答えられません。

   ```tsx
   const previous = thenableState[index];
   if (previous === undefined) {
     thenableState.push(thenable);
   } else {
     if (previous !== thenable) {
       // 前のthenableを再利用し、新しいものを捨てます。コンポーネントは恒等であると仮定できます。

       // 意図的に無視するPromiseの未処理の拒否エラーを避けるために、それらを処理します。
       thenable.then(noop, noop);
       thenable = previous;
     }
   }
   ```

2. パート 2：thenable を追跡する
   前に thenable を追跡したことがあるか、初めて遭遇したかによって、2 つのケースがあります。

   thenable を追跡することは、thenable 自体を変更する`then(onFullfilement, onRejection)`コールバックを追加することを意味します：

   以下のコードをよく読んで理解してください：

   ```tsx
   const pendingThenable: PendingThenable<T> = thenable;
   pendingThenable.status = "pending";
   pendingThenable.then(
     (fulfilledValue) => {
       if (thenable.status === "pending") {
         const fulfilledThenable: FulfilledThenable<T> = thenable;
         fulfilledThenable.status = "fulfilled";
         fulfilledThenable.value = fulfilledValue;
       }
     },
     (error: mixed) => {
       if (thenable.status === "pending") {
         const rejectedThenable: RejectedThenable<T> = thenable;
         rejectedThenable.status = "rejected";
         rejectedThenable.reason = error;
       }
     }
   );
   ```

   しかし、thenable が既に追跡されている場合、単にその状態を確認します：

   ```tsx
   switch (thenable.status) {
     case "fulfilled": {
       const fulfilledValue: T = thenable.value;
       return fulfilledValue;
     }
     case "rejected": {
       const rejectedError = thenable.reason;
       checkIfUseWrappedInAsyncCatch(rejectedError);
       throw rejectedError;
     }
     // ... other code
   }
   ```

   - 状態が`fulfilled`の場合、`use`フックは値を返します
   - 状態が`rejected`の場合、`use`フックはエラーをスローします

   状態が`pending`の場合、React は特別な例外オブジェクトである`SuspenseException`をスローし、thenable が解決または拒否されるまでツリーを一時停止します。

   これにより、コンポーネントはデータがある場合にのみレンダリングされ、それ以外の場合はスローされます。

   :::note
   `use`フックは、エラーをキャッチするためにツリーにエラーバウンダリを配置する必要があります。
   :::

:::warning
`use`フックは、手動でプロミスをキャッシュ/メモ化する必要があります。

`React.cache`実験的な API は、これを助けることを目的としています。
:::

### 例

jsonplaceholder の公開 API からユーザーの詳細を取得することを想定します。

これを実現するために、単純なキャッシュを作成して、プロミスをメモ化し、無限レンダリングを避けることができます。そこで、関数用のダミーメモライザーを作成します：

```tsx
// キャッシュには1つのパラメータを使用すると仮定します
// ユーザーIDです。
// React.cacheはこれを解決する一般的なソリューションです。
// 明確にするため、userIdのみを使用します
function createCache(asyncFunc) {
  let cache = {};

  return function exec(...args) {
    let cacheId = args[0];
    let existing = cache[cacheId];
    if (existing) {
      return existing;
    }

    let result = asyncFunc.apply(null, args);
    cache[cacheId] = result;
    return result;
  };
}
```

次に、ダミーエラーバウンダリを作成します：

```tsx
class ErrorBoundary extends React.Component {
  state = { error: null };
  componentDidCatch(error) {
    this.setState((prev) => ({ ...prev, error }));
  }
  render() {
    const { error } = this.state;
    if (error) {
      return (
        <>
          <pre>{error.toString()}</pre>
          <button
            onClick={() => this.setState((prev) => ({ ...prev, error: null }))}
          >
            Reset
          </button>
        </>
      );
    }
    return this.props.children;
  }
}
```

最後に、このコードを利用します：

```tsx
async function fetchUserById(userId) {
  let result = await axios.get(
    `https://jsonplaceholder.typicode.com/users/${userId}`
  );
  return result.data;
}

let getUserDetails = createCache(fetchUserById);

let IDS = [1, 2, 3, 4, 5, 10, 11];

function UserDetails({ id }) {
  let details = React.use(getUserDetails(id));

  return (
    <details open>
      <pre>{JSON.stringify(details, null, 4)}</pre>
    </details>
  );
}
function Example() {
  let [userId, setUserId] = React.useState(IDS[0]);
  return (
    <div className="App">
      {IDS.map((id) => (
        <button
          onClick={() => {
            setUserId(id);
          }}
          key={id}
        >
          {`User ${id}`}
        </button>
      ))}
      <React.Suspense fallback={`Loading user ${userId}`}>
        <UserDetails id={userId} />
      </React.Suspense>
    </div>
  );
}

export default function App() {
  return (
    <ErrorBoundary>
      <Example />
    </ErrorBoundary>
  );
}
```

この[デモ](https://codesandbox.io/s/lucid-curran-x8xxlj?file=/src/App.js)を表示して操作できます：

<iframe src="https://codesandbox.io/embed/lucid-curran-x8xxlj?fontsize=14&hidenavigation=1&theme=dark"
style={{width: "100%", height: "500px", border: 0, borderRadius: 4}}
title="React.use demo"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

## `useCallback`フックの仕組み

`useCallback`フックを使用すると、依存関係が変更されるまで関数参照を保持できます。

### シグネチャ

`useCallback`は以下のように定義されています：

```tsx
function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

直接的には存在しない関数ですが、前述のように[`mountCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2602)と[`updateCallback`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2609)関数があり、同じシグネチャを持ちます：

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

### 実装

#### マウント時

コンポーネントが最初にレンダリングされるときに`useCallback`を使用すると、呼び出しは`mountCallback`によってインターセプトされ、最も簡単なフックです：

```tsx
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ステップ1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // ステップ3
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ステップ 1**：前述のフックデータ構造をマウントします
- **ステップ 2**：依存関係を定義します。パラメータが省略された場合は`null`を使用します
- **ステップ 3**：コールバックと依存関係をフックの`memoizedState`プロパティに格納します

`useCallback`は渡された値をそのまま返します。通常、インライン関数を直接定義するか、コンポーネント本体内で定義された関数を渡します。

マウント時に`useCallback`は依存関係については関心がありません。単にそれらを後で使用するために格納するだけです。

#### 更新時

更新時、目的は依存関係が変更された場合にのみ新しい関数参照を与えることです。

```tsx
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {
  // ステップ1
  // highlight-next-line
  const hook = updateWorkInProgressHook();
  // ステップ2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  // ステップ3
  // highlight-next-line
  if (nextDeps !== null) {
    const prevDeps: Array<mixed> | null = prevState[1];
    // ステップ4
    // highlight-next-line
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  // ステップ5
  // highlight-next-line
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

- **ステップ 1**：フックデータ構造オブジェクトを作成または再利用します
- **ステップ 2**：依存関係配列を推論します。指定されていない場合は`null`を使用します
- **ステップ 3**：依存関係が null でない場合（undefined を指定するとメモ化しないことを意味します）、前の依存関係と比較します
- **ステップ 4**：前の依存関係と次の依存関係を比較し、同じ場合は前の値（`memoizedState`配列の最初の要素）を返します。比較方法は後で説明します
- **ステップ 5**：依存関係が変更されたか、メモ化していない場合、`mountCallback`と同様に`[callback, nextDeps]`をフックの`memoizedState`プロパティに格納します

The [`areHookInputsEqual`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L451)
関数は依存配列を使用するすべてのフックで使用されます。この関数は：

- 前回の依存配列がない場合、常に`false`を返します。これにより React はフックの返り値を再計算します。つまり、依存配列が空（`[]`）の場合、毎回のレンダーで更新されます
- 両方の配列をループし、`Object.is`で個々の値を比較します

## How useContext works

The [`useContext` hook](https://react.dev/reference/react/useContext) allows you
to read and subscribe to a [React Context](https://medium.com/@mohamedelayadi/react-context-all-you-need-to-know-40de6662b074)
value.

### Signature

[`useContext` hook](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L713)
is defined as follows:

```tsx
function readContext<T>(context: ReactContext<T>): T {
  // [Not Native Code]
}
```

Where the unique parameter refers to a React context object created by the
[`React.createContext` API.](https://react.dev/reference/react/createContext)

### Implementation

`useContext` uses the [`readContextForConsumer`](https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L740)
function:

```tsx
export function readContext<T>(context: ReactContext<T>): T {
  // ...dev checks
  return readContextForConsumer(currentlyRenderingFiber, context);
}
```

The `readContextForConsumer` is responsible for giving you the current context
value and also subscribe to it for future changes. Let's dig into its
implementation:

```tsx
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  // step 1
  // highlight-next-line
  const value = isPrimaryRenderer
    ? context._currentValue
    : context._currentValue2;

  // step 2
  // highlight-next-line
  if (lastFullyObservedContext === context) {
    // Nothing to do. We already observe everything in this context.
    // step 3
    // highlight-next-line
  } else {
  }
}
```

- **Step 1**: Decides on the internal context value based on the
  `isPrimaryRenderer` renderer property. I don't have much experience with this
  property, but you set it while creating a custom React renderer. Primary means
  that your renderer renders the whole page, and secondary means that you are
  writing a renderer meant to be used on top of another one. In our case, which
  is React-DOM, it is a primary renderer, so we take the `_currentValue` value.
- **Step 2**: The second step will actually bail out reading and subscribing to
  this context. React uses the `lastFullyObservedContext` module variable, which
  [seems to be unused](https://github.com/search?q=repo%3Afacebook%2Freact%20lastFullyObservedContext&type=code).
  I haven't seen it being written in the whole codebase.
- **Step 3**: The third step is where subscription occurs, let's dig into it.

### How Context subscription works

The context subscription is stored in the `fiber.dependencies` property in
a linked list fashion (again):

```tsx
// simplified
function readContextForConsumer<T>(
  consumer: Fiber | null,
  context: ReactContext<T>
): T {
  const value = context._currentValue;

  const contextItem = {
    context: context as ReactContext<any>,
    memoizedValue: value,
    next: null,
  };
}
```

Then, when this is the first `useContext` in this component, it will add the
following object as `dependencies`:

```tsx
// simplified

// the lastContextDependency variable is reset in the prepareToReadContext
// function called when we are about to update components
// (updateFunctionComponent and others)
if (lastContextDependency === null) {
  lastContextDependency = contextItem;
  // consumer is the work in progress fiber
  consumer.dependencies = {
    lanes: NoLanes,
    firstContext: contextItem,
  };
}
```

Or else, it will add the context item as the `next` property of the previous one:

```tsx
if (lastContextDependency === null) {
  // ...
} else {
  lastContextDependency = lastContextDependency.next = contextItem;
}
```

And that's it!

### Updates

When a component rendering a `ContextProvider` gets updated, React will check
on the `value` `prop`, and if it changed, it will propagate the changes.

This section will be explained in how rendering of a `ContextProvider` works.

:::note
Similarly to the `use` hook, `useContext` can be called conditionally on render.

But you cannot call it inside other hooks or outside the render phase. Because
it needs the currently rendering fiber to be able to perform subscription.
:::

## How useEffect works

[The `useEffect` hook](https://react.dev/reference/react/useEffect) allows you
to register passive effects on your component.

Passive effects run as the last part of the `commit` phase of the render.
It is either synchronous for `SyncLane`s for `Asynchronous` for the rest lanes.

From the docs:

> useEffect is a React Hook that lets you synchronize a component with an
> external system.

This means that you should **only** use this hook to keep your component in sync
with external systems, such as the browser APIs (focus, resize, blur...) or
some external stores.

### Signature

The `useEffect` hooks is defined as follows:

```tsx
function useEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

It accepts two parameters:

- `create`: the effect creation function, it doesn't accept any parameters, and
  return either nothing, or a `cleanup` function. The cleanup function is
  responsible for cleaning the effect work: such as unsubscribing from an event.
- `deps`: The optional dependencies array, that will result in running the
  effect creation again whenever a dependency changes. If this parameter is
  omitted, the effect will run at **the end of every render phase.**

:::note
If your component performs a render phase state update, the effect won't run
twice. But rather, the effects are ran at the commit phase, after the render is
performed.
:::

### Implementation on mount

Like normal hooks, this hook relies on `mountWorkInProgressHook()`, which
creates the object seen in the start of this section.
`mountEffect` calls a function called `mountEffectImpl`.

:::note
`mountEffectImpl` is called from all the other effect hooks (`useLayoutEffect`,
`useInsertionEffect` and other hooks that add special effects.)
:::

```tsx
function mountEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  mountEffectImpl(
    PassiveEffect | PassiveStaticEffect,
    HookPassive,
    create,
    deps
  );
}
```

Let's discuss the previous snippet before going any longer, to do so, we need
to observe the [`mountEffectImpl` signature:](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2331)

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- `fiberFlags`: Flags that will be added to the component using the effect
- `hookFlags`: Flags that define [the effect itself](https://github.com/facebook/react/blob/9cdf8a99edcfd94d7420835ea663edca04237527/packages/react-reconciler/src/ReactHookEffectTags.js#L10),
  possible values are: `Insertion`, `Layout` and `Passive`. `Passive` is used
  for `useEffect`.
- `create`: The effect function
- `deps`: The effect dependencies

Finally, let's take a look at the `useEffectImpl` function before diving more
in this maze:

```tsx
function mountEffectImpl(
  fiberFlags: Flags,
  hookFlags: HookFlags,
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  currentlyRenderingFiber.flags |= fiberFlags;
  // step 4
  // highlight-next-line
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    createEffectInstance(),
    nextDeps
  );
}
```

- **Step 1**: Mount the hook data structure seen in the top of this section
- **Step 2**: Define the dependencies to use, if the parameter is omitted, `null`
  is used.
- **Step 3**: Add the received fiberFlags to the currently rendering fiber. In
  the case of `useEffect`, it is: `PassiveEffect | PassiveStaticEffect`, which
  is a natural number (`8390656` at the moment of writing these words).
- **Step 4**: Store the `memoizedState` value of this hook, which is the result
  of calling the `pushEffect`.

The [`createEffectInstance` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2236)
just returns the object `{ destroy: undefined }`. It will be used to store the
effect cleanup function (if any).

So, the last part of this is to take a look at the [`pushEffect` function:](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2202)

```tsx
function pushEffect(
  tag: HookFlags, // useEffect: Passive
  create: () => (() => void) | void,
  inst: EffectInstance, // { destroy: undefined }
  deps: Array<mixed> | null
): Effect {
  // [Not Native Code]
}
```

#### Create the effect object

This object is created every render for every effect you use, it stores the
relevant information needed to perform well.

```tsx
const effect: Effect = {
  tag, // The hook flag
  create, // the provided effect function
  inst, // { destroy: undefined }
  deps, // the provided dependencies or null
  // Circular
  next: null, // this will be set next
};
```

#### Link the effect to the function component update queue

Next, React will reference the `currentlyRenderingFiber.updateQueue` property,
and if null, it will initialize it:

```tsx
let componentUpdateQueue: null | FunctionComponentUpdateQueue =
  currentlyRenderingFiber.updateQueue;
if (componentUpdateQueue === null) {
  componentUpdateQueue = createFunctionComponentUpdateQueue();
  currentlyRenderingFiber.updateQueue = componentUpdateQueue;
  // this creates a circular reference (it will be teared a part when committing)
  componentUpdateQueue.lastEffect = effect.next = effect;
}
```

The update queue created by `createFunctionComponentUpdateQueue` looks like this:

```tsx
const updateQueue = {
  lastEffect: null,
  events: null,
  stores: null,
};

// when the memoCache feature is enabled, it will add a memoCache property
// initialized by null
```

It is used as a circular linkedList, when we store the lastEffect (its `next`
property will then point to the `first` effect in the list.)

When the component `updateQueue` is already initialized (we've called an
effect before in this render, or another hook initialized it), React will take
the `lastEffect` property and:

- If `null` (may happen if the updateQueue was initialized by events or stores
  and not by an effect), it will do the same as before: will create a circular
  reference by the `effect` object and itself, and store it in the `lastEffect`
  property of the queue.
  ```tsx
  const lastEffect = componentUpdateQueue.lastEffect;
  if (lastEffect === null) {
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    // take a look next
  }
  ```
- Not `null` means that we called an effect hook before in this render pass,
  and in this case, React will execute this code:
  ```tsx
  const firstEffect = lastEffect.next;
  lastEffect.next = effect;
  effect.next = firstEffect;
  componentUpdateQueue.lastEffect = effect;
  ```
  Don't be confused, let's break the previous code:
  - First, reference the first effect on the list (well, since it is a circular
    linked list, the first is the `next` of the last).
  - Add the new effect as the `next` of the previous `lastEffect`: well, this is
    the new last.
  - The new effect (which is the new last) will point then to the `firstEffect`
    in its `next` property.
  - Finally, mark the new effect as the lastEffect in the list in the component
    `updateQueue`.

Finally, the `pushEffect` function will return the new effect object defined
below and store it in the `hook.memoizedState`.

### Implementation on update

On updates, `useEffect` will [call `updateEffect`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2407)
from the`HooksDispatcherOnUpdate` dispatcher, which will delegate to the
[`updateEffectImpl` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2348).

:::note
These functions have the same signature as the mount ones.

The only difference to note is the passed `fiberFlags`: On mount we passed
`PassiveEffect | PassiveStaticEffect`, and on update we pass only `PassiveEffect`.

At the moment of writing these words, I cannot seem to know what causes this
difference, I cannot find any place in [the React codebase](https://github.com/search?q=repo%3Afacebook%2Freact%20PassiveStatic&type=code)
where the`PassiveStaticEffect` is used to build any decision. Apart from some
todos, so maybe an incoming/unfinished feature.

But there is also the following comment where static [flags are declared:](https://github.com/facebook/react/blob/768f965de2d4c6be7f688562ef02382478c82e5b/packages/react-reconciler/src/ReactFiberFlags.js#L59)

```tsx
// Static tags describe aspects of a fiber that are not specific to a render,
// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
// This enables us to defer more work in the unmount case,
// since we can defer traversing the tree during layout to look for Passive effects,
// and instead rely on the static flag as a signal that there may be cleanup work.
export const RefStatic = /*                    */ 0b0000001000000000000000000000;
export const LayoutStatic = /*                 */ 0b0000010000000000000000000000;
export const PassiveStatic = /*                */ 0b0000100000000000000000000000;
export const MaySuspendCommit = /*             */ 0b0001000000000000000000000000;
```

:::

In addition to passed parameters, the implementation surely differ, because
on updates, we need to check if dependencies changed:

So, first, the `updatewWorkInProgressHook` function is called.

```tsx
function updateEffectImpl(
  fiberFlags: Flags, // PassiveEffect
  hookFlags: HookFlags, // HookPassive for useEffect
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  // the effect from the previous render
  const effect: Effect = hook.memoizedState;
  // the effect instance from the previous render, it will be reused
  const inst = effect.inst;

  // currentHook is null on initial mount when rerendering after a render phase
  // state update or for strict mode.
  // we've seen currentHook at the start of this section, in updateWIPHook
  if (currentHook !== null) {
    if (nextDeps !== null) {
      const prevEffect: Effect = currentHook.memoizedState;
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // pushEffect was described on mount above, we call it here too
        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);
        return;
      }
    }
  }

  // add the fiberFlags to the fiber.flags
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    inst,
    nextDeps
  );
}
```

:::tip
This is how useEffect works, the effect functions are executed in the commit
phase. During render, we just store the relevant information.

Please refer to the [`how commit works` section](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)
for more information about the timing of invocation of each type of effects.
:::

## How useImperativeHandle works

The [`useImperativeHandle` hook](https://react.dev/reference/react/useImperativeHandle)
is defined in the official docs as:

> useImperativeHandle is a React Hook that lets you customize the handle exposed
> as a ref.

In human words for the rest of us, this means that it lets you override what
a component is exposing as ref (the handle), for example, if you want to add a
function to your custom button, let's say, you want to add a `sayHiTo(name)`
function to it that will show an `alert`, and so on.

### Signature

The `useImerativeHandle` is defined as follows:

```tsx
function mountImperativeHandle<T>(
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void,
  create: () => T,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

- **ref**: The ref, created by `useRef` or `createRef`, can be also a ref
  callback
- **create**: The function that will return the new ref '`handle`'
- **deps**: The hook dependencies, the create function will be called again
  when a dependency changes.

### Implementation on mount

When the component using `useImperativeHandle` renders for the first time,
it will call the [`mountImperativeHandle` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2533)
which is implemented as follows:

```tsx
// step 1
// highlight-next-line
const effectDeps =
  deps !== null && deps !== undefined ? deps.concat([ref]) : null;
// step 2
// highlight-next-line
mountEffectImpl(
  UpdateEffect | LayoutStaticEffect,
  HookLayout,
  imperativeHandleEffect.bind(null, create, ref),
  effectDeps
);
```

- **Step 1**: Compute the real hook dependencies: The provided ones in addition
  to the ref object itself. Maybe we can skip adding the ref to the array and
  suppose the developer should add it manually ? But this won't be backward
  compatible anyway.
- **Step 2**: The second step is to mount an effect (wait! what ? 😳)

Yes, you've read that right, `useImperativeHandle` will insert a special layout
effect whose `create` function is the [`imperativeHandleEffect` function](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2503)

:::tip
During the commit phase, React will attach refs at the `Layout` phase. That's
why the whole work is used as a layout effect.
:::

### Implementation on update

On updates, `useImperativeHandle` will calculate the deps like on mount,
and then call to `updateEffectImpl` with only `UpdateEffect` as fiber flags.

This brings us to the real work.

### How `imperativeHandleEffect` works

#### Signature

```tsx
function imperativeHandleEffect<T>(
  create: () => T,
  ref: { current: T | null } | ((inst: T | null) => mixed) | null | void
): void | (() => void) {
  // [Not Native Code]
}
```

#### Implementation

The implementation will perform the work based on whether the passed ref is
a ref object or a ref callback, and either ways will call your passed `create`
function and return a cleanup function for the layout effect:

```tsx
if (typeof ref === "function") {
  // step 1
  // highlight-next-line
  const refCallback = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refCallback(inst);
  // step 4
  // highlight-next-line
  return () => {
    refCallback(null);
  };
}
```

- **Step 1**: keep track of the passed ref callback reference
- **Step 2**: call the useImperativeHandle create function, that will produce
  the new ref handle
- **Step 3**: call the ref callback with the resulting handle
- **Step 4**: return the layout effect cleanup to call the ref callback again
  with a null value

Alternatively, when the passed `ref` is a `refObject`, then
`imperativeHandleEffect` will:

```tsx
// this is origannly an else if
if (ref !== null && ref !== undefined) {
  // step 1
  // highlight-next-line
  const refObject = ref;
  // step 2
  // highlight-next-line
  const inst = create();
  // step 3
  // highlight-next-line
  refObject.current = inst;
  // step 4
  // highlight-next-line
  return () => {
    refObject.current = null;
  };
}
```

- **Step 1**: keep track of the passed ref object reference
- **Step 2**: call the useImperativeHandle create function, that will produce
  the new ref handle
- **Step 3**: attach the resulting ref handle to the `current` property of the
  ref object
- **Step 4**: return the layout effect cleanup that will reset the `current`
  property to null

And that's it!

:::note
As stated before, the `imperativeHandleEffect` will be invoked during the
layout effect iteration of the commit phase. It won't be called right away
during render.
:::

## How useInsertionEffect works

The [`useInsertionEffect` hook](https://react.dev/reference/react/useInsertionEffect)
by definition:

> Allows inserting elements into the DOM before any layout effects fire

As stated in its official documentation section, it should only be used by
css-in-js library authors, if not, please use `useLayoutEffect` or `useEffect`.

### Signature

Same as other effects, the `useInsertionEffect` is defined as follows:

```tsx
function useInsertionEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### Implementation

The `useInsertionEffect` implementation is the [same as `useEffect`](#how-useeffect-works),
the only difference is the `flags` being passed on mount to `mountEffectImpl`
and on update to `updateEffectImpl`:

- On mount: React passes `UpdateEffect` as fiber flags and `HookInsertion` as
  hook flags.
- On update: React passes `UpdateEffect` as fiber flags and `HookInsertion` as
  hook flags.

And that's it! All effects only differ in the flags.

## How useLayoutEffect works

The [`useLayoutEffect` hook](https://react.dev/reference/react/useLayoutEffect)
by definition is:

> Is a version of useEffect that fires before the browser repaints the screen.

Well, that's not totally true when it comes to comparing it to useEffect,
the [`how commit works` section](/how-react-works/docs/react-dom/how.commit.works#how-commitroot-works)
will reveal more information about that.

`useLayoutEffect` allows you to register effect that run after the render phase
synchronously after mutating the dom elements.

Its synchronous nature blocks the browser's main thread and thus prevent it from
partially painting the new render resulting UI. Which makes us often say:
`useLayoutEffect` runs before the browser's paint.

`useLayoutEffect` runs at the same time as `ClassComponent` lifecycle methods
(`componentDidMount` and `componentDidUpdate`)

### Signature

Same as other effects, the `useInsertionEffect` is defined as follows:

```tsx
function useLayoutEffect(
  create: () => (() => void) | void,
  deps: Array<mixed> | void | null
): void {
  // [Not Native Code]
}
```

### Implementation

The `useLayoutEffect` implementation is the [same as `useEffect`](#how-useeffect-works),
the only difference is the `flags` being passed on mount to `mountEffectImpl`
and on update to `updateEffectImpl`:

- On mount: React passes `UpdateEffect | LayoutStaticEffect` as fiber flags and
  `HookLayout` as hook flags.
- On update: React passes `UpdateEffect` as fiber flags and `HookLayout` as
  hook flags.

And that's it! All effects only differ in the flags.

## How useMemo works

The [`useMemo` hook](https://react.dev/reference/react/useMemo) allows you to
cache a value until a dependency changes.

### Signature

`useMemo` is defined as follows:

```tsx
function useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {
  // [Not Native Code]
}
```

Where:

- **`nextCreate`**: The function that will output our cached value
- **`deps`**: The dependencies

### Implementation on mount

On mount, `useMemo` will [call `mountMemo`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L2623)
which is defined as follows:

```tsx
function mountMemo<T>(
  nextCreate: () => T,
  deps: Array<mixed> | void | null
): T {
  // step 1
  // highlight-next-line
  const hook = mountWorkInProgressHook();
  // step 2
  // highlight-next-line
  const nextDeps = deps === undefined ? null : deps;
  // step 3
  // highlight-next-line
  const nextValue = nextCreate();
  // step 4
  // highlight-next-line
  hook.memoizedState = [nextValue, nextDeps];
  // step 5
  // highlight-next-line
  return nextValue;
}
```

- **Step 1**: create the hook object on mount
- **Step 2**: calculate the deps to use, either the provided ones or `null`
- **Step 3**: calculate the initial memo value
- **Step 4**: store `[nextvalue, nextDeps]` as the `memoizedState` of the hook
- **Step 5**: return the cached value

:::note
When in development mode and under StrictMode, React will call the `nextCreate`
twice:

```tsx
// initialized in the renderWithHooks function
if (shouldDoubleInvokeUserFnsInHooksDEV) {
  nextCreate();
}
```

:::
