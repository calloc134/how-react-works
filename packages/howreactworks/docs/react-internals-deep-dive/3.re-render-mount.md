---
title: React の再レンダリングの内部動作
---

# React は内部的にどのように再レンダーするのか？

:::info
[React Internals Deep Dive](/series/react-source-code-walkthrough.html) シリーズのエピソード 3。[Youtube で解説しています](https://www.youtube.com/watch?v=0GM-1W7i9Tk&list=PLvx8w9g4qv_p-OS-XdbB3Ux_6DMXhAJC3&index=3)
:::

:::warning
[React@18.2.0](https://github.com/facebook/react/releases/tag/v18.2.0) ベース。新しいバージョンでは実装が変更されている可能性があります
:::

[初期マウント時の React の動作](/2023-07-14-initial-mount/)について説明しました。初期マウント後、React は reconciliation プロセスを通じて DOM を可能な限り再利用しようとします。このエピソードでは、デモのボタンクリック後の再レンダー処理の内部動作を解説します。

デモは前回のエピソードとは異なります。[こちらで試すことができます](/demos/react/overview/re-render.html)。

## 目次

- [1. トリガーフェーズでの再レンダー](#1-re-render-in-trigger-phase)
  - [1.1 `lanes` と `childLanes`](#11-lanes-and-childlanes)
- [2. レンダーフェーズでの再レンダー](#2-re-render-in-render-phase)
  - [2.1 基本的なレンダリングロジックは初期マウント時と同じ](#21-basic-rendering-logic-is-the-same-as-initial-mount)
  - [2.2 React は新しい Fiber Node 作成前に既存のものを再利用](#22-react-reuses-redundant-fiber-nodes-before-creating-new-ones)
  - [2.3 `beginWork()` の Update ブランチ](#23-the-update-branch-in-beginwork)
  - [2.4 `attemptEarlyBailoutIfNoScheduledUpdate()` 内の Bailout ロジック](#24-bailout-logic-inside-attemptearlybailoutifnoscheduledupdate)
  - [2.5 `memoizedProps` vs `pendingProps`](#25-memoizedprops-vs-pendingprops)
  - [2.6 `updateFunctionComponent()` による関数コンポーネントの再レンダーと children の reconcile](#26-updatefunctioncomponent-re-renders-function-components-and-reconcile-children)
  - [2.7 `reconcileSingleElement()` による単一要素の調整](#27-reconcilesingleelement)
  - [2.8 コンポーネントが再レンダーされると、そのサブツリーはデフォルトで再レンダーされる](#28-once-a-component-is-re-rendered-their-subtree-is-re-rendered-by-default)
  - [2.9 `updateHostComponent()` によるホストコンポーネントの更新](#29-updatehostcomponent)
  - [2.10 `reconcileChildrenArray()` による Fiber の作成と削除](#210-reconcilechildrenarray-creates-and-deletes-fibers-as-needed)
  - [2.11 `placeChild()` と `deleteChild()` による Fiber フラグのマーキング](#211-placechild-and-deletechild-marks-fiber-with-flags)
  - [2.12 `updateHostText()` によるテキストノードの更新](#212-updatehosttext)
  - [2.13 `completeWork()` による HostComponent の更新マーキングと DOM ノード作成](#213-completework-marks-the-update-of-hostcomponent-and-creates-dom-nodes-if-necessary)
- [3. コミットフェーズでの再レンダー](#3-re-render-in-commit-phase)
  - [3.1 `commitMutationEffectsOnFiber()` による挿入/削除/更新の開始](#31-commitmutationeffectsonfiber-kicks-off-the-commit-of-insertiondeletionupdate)
  - [3.2 削除処理は子要素と自身の処理前に最初に実行](#32-deletion-are-processed-first-before-processing-children-and-self)
  - [3.3 次に挿入処理が実行](#33-insertions-are-processed-next)
  - [3.4 更新処理は最後に処理](#34-updates-are-handled-at-last)
- [4. まとめ](#4-summary)

## 1. トリガーフェーズの再レンダー

React は[初期マウント](/2023-07-14-initial-mount/)で Fiber Tree と DOM ツリーを構築します。完了したとき、以下の 2 つのツリーが存在します。

![Fiber Tree Initial](https://jser.dev/static/rerender/1.avif)

### 1.1 `lanes` と `childLanes`

Lane は保留中の work の優先度を表します。Fiber Node は以下を持ちます:

1. `lanes` => 自身の保留中の work 用
2. `childLanes` => サブツリーの保留中の work 用

:::info
Lanes の詳細は [What are Lanes in React source code](/react/2022/03/26/lanes-in-react/) を参照
:::

ボタンがクリックされると`setState()`が呼び出されます:

1. root からターゲット fiber までのパスに`lanes`と`childLanes`がマークされ、次回のレンダーでチェックが必要な箇所を示す
2. `scheduleUpdateOnFiber()`によってアップデートがスケジュールされ、最終的に`ensureRootIsScheduled()`が呼び出されて
   Scheduler に`performConcurrentWorkOnRoot()`が登録されます。これは[初期マウント](/2023-07-14-initial-mount/)と同様のプロセスです。

重要な点は、イベントの優先度がアップデートの優先度を決定することです。`click`イベントは`DiscreteEventPriority`であり、`SyncLane`（高優先度）にマッピングされます。

:::info
`useState()`の動作詳細は [How does useState() work internally in React](/2023-06-19-how-does-usestate-work) を参照
:::

詳細は割愛しますが、最終的に作業対象となる以下の Fiber Tree が得られます。

![Fiber Tree Lanes](https://jser.dev/static/rerender/2.avif)

## 2. レンダーフェーズでの再レンダー

### 2.1 基本的なレンダリングロジックは初期マウント時と同じ

`click`イベントの場合、レンダーレーンは SyncLane であり、これはブロッキングレーンです。
したがって、初期マウントと同様に、`performConcurrentWorkOnRoot()`内で concurrent mode はまだ有効になっていません。

:::info
concurrent mode が有効になっている場合は、[How does useTransition() work internally in React?](/2023-05-19-how-does-usetransition-work/)を参照
:::

以下は全体のプロセスをまとめたコードです。

```javascript
do {
  try {
    workLoopSync();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;

  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  // ~ この行は重要です。[2.5 memoizedProps vs pendingProps](#25-memoizedprops-vs-pendingprops)で説明します
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // 新しいworkが生成されない場合、現在のworkを完了
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

詳細な説明については、[前回のエピソード](/2023-07-14-initial-mount/#32-renderrootsync)を参照してください。
ここでは、React が Fiber Tree をトラバースし、必要に応じて fiber を更新することを覚えておいてください。

### 2.2 React は新しい Fiber Node 作成前に既存のものを再利用

[初期マウント](/2023-07-14-initial-mount/)では、Fiber がスクラッチから作成されます。
しかし実際には、React は最初に Fiber Node を再利用しようとします。

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  // ~ currentは現在のバージョン
  // ~ alternateは以前のバージョンを指す

  if (workInProgress === null) {
    // ~ if we have to create from scratch
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    // ~ 最初から作成する必要がある場合
    // ツリーのバージョンは最大でも 2 つしか必要ないことがわかっているため、
    // ダブル バッファリングのプーリング手法を使用します。
    // ここで、再利用できる「その他の」未使用ノードをプールします。
    // これは、更新されないものに対して余分なオブジェクトを割り当てないように、遅延して作成されます。
    // また、必要に応じて余分なメモリを再利用することもできます。
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      // ~ ------
      current.key,
      current.mode,
    );
    ...
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ~ 前のバージョンを再利用可能な場合
    workInProgress.pendingProps = pendingProps;
    // ~ 再利用可能なため、新しいFiber Nodeを作成する必要はありません
    // ~ 代わりに必要なプロパティを更新して再利用します
    // Blocksがtypeにデータを保存するため必要
    workInProgress.type = current.type;

    // alternateは既に存在
    // effect tagをリセット
    workInProgress.flags = NoFlags;

    // エフェクトは無効化
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }

  // 静的エフェクト以外をリセット
  // 静的エフェクトは特定のレンダーに紐づきません
  workInProgress.flags = current.flags & StaticMask;
  // ~ lanesとchildLanesをコピー
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;


  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  ...
  return workInProgress;
}
```

`current`が Fiber Tree 上にないすべての Fiber Node は再利用できます。

再レンダープロセスでは、冗長な`HostRoot`は`prepareFreshStack()`で再利用されます。

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  ...
  workInProgressRoot = root;
  // ~ ルートの`current`はHostRootのFiberNodeです
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  finishQueueingConcurrentUpdates();
  return rootWorkInProgress;
}
```

したがって、再レンダリングを以下のヘッドから開始します。

![Starting Point](https://jser.dev/static/rerender/3.avif)

色を付けてみましょう。

![Starting Point Colored](https://jser.dev/static/rerender/4.avif)

### 2.3 `beginWork()` の Update ブランチ

`beginWork()`内には、更新を処理する重要なブランチがあります。
このブランチは、初期マウントのエピソードでは扱いませんでした。

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (current !== null) {
    // ~ If current is not null, it means *NOT* initial mount,
    // ~ it has previous version of Fiber Node and also DOM nodes
    // ~ if it is HostComponent. Thus React is able to optimize by possibly
    // ~ avoiding going deeper in the subtree - bailout!
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (
      oldProps !== newProps ||
      // ~ Here it is using `===` not shallow equal
      // ~ which leads to important behavior of React rendering
      hasLegacyContextChanged() ||
      // Force a re-render if the implementation changed due to hot reload:
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else {
      // Neither props nor legacy context changes. Check if there's a pending
      // update or context change.
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        // ~ This checks the `lanes` on  the fibers
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        // If this is the second pass of an error or suspense boundary, there
        // may not be work scheduled on `current`, so we check for this flag.
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // No pending updates or context. Bail out now.
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          // ~ If there is no update on this fiber, React tries to bailout
          // ~ but only if there are no props or context changes
          current,
          workInProgress,
          renderLanes,
        );
      }
     ...
    }
  } else {
    didReceiveUpdate = false;
    // ~ This is mount branch we've already covered before
    ...
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        //------------------------
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    //--------------
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    //-------------------
    case HostText:
      return updateHostText(current, workInProgress);
    //--------------
    ...
  }

}
```

### 2.4 `attemptEarlyBailoutIfNoScheduledUpdate()` 内の Bailout ロジック

この関数は、不要な場合はできるだけ早くレンダリングを停止しようとします。

```javascript
function attemptEarlyBailoutIfNoScheduledUpdate(
  current: Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  // This fiber does not have any pending work. Bailout without entering
  // the begin phase. There's still some bookkeeping we that needs to be done
  // in this optimized path, mostly pushing stuff onto the stack.
  switch (workInProgress.tag) {
    case HostRoot:
      pushHostRootContext(workInProgress);
      const root: FiberRoot = workInProgress.stateNode;
      pushRootTransition(workInProgress, root, renderLanes);

      if (enableCache) {
        const cache: Cache = current.memoizedState.cache;
        pushCacheProvider(workInProgress, cache);
      }
      resetHydrationState();
      break;
    case HostComponent:
      pushHostContext(workInProgress);
      break;
    ...
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  //----------------------------
}
```

```javascript
function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  // Check if the children have any pending work.
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // ~ Here we see `childLanes` are checked
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.

    if (enableLazyContextPropagation && current !== null) {
      // Before bailing out, check if there are any context changes in
      // the children.
      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);
      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
        return null;
        // ~ So if there is no update on fiber itself and its subtree
        // ~ Then of course, we can just stop going deeper in the tree
        // ~ by returning null
      }
    } else {
      return null;
      // ~ So if there is no update on fiber itself and its subtree
      // ~ Then of course, we can just stop going deeper in the tree
      // ~ by returning null
    }
  }

  // This fiber doesn't have work, but its subtree does. Clone the child
  // fibers and continue.
  cloneChildFibers(current, workInProgress);
  // ~ Though its name is clone, it actually either creates new children nodes
  // ~ or reusing the previous nodes
  return workInProgress.child;
  // ~ We just return the child directly, React process it as next fiber
  // ~ For more, refer to [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/)
}

export function cloneChildFibers(
  current: Fiber | null,
  workInProgress: Fiber
): void {
  if (current !== null && workInProgress.child !== current.child) {
    throw new Error("Resuming work not yet implemented.");
  }

  if (workInProgress.child === null) {
    return;
  }

  let currentChild = workInProgress.child;
  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  // ~ So in cloneChildFibers(), child fibers are created from its previous version
  // ~ but with new pendingProps, which is set during reconciliation
  workInProgress.child = newChild;
  newChild.return = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(
      currentChild,
      currentChild.pendingProps
    );
    newChild.return = workInProgress;
  }
  newChild.sibling = null;
}
```

Bailout プロセスをまとめると以下のようになります

1.  fiber が props/context の変更を持たず、かつ pending work（空の`lanes`）がない場合
    1.  子孫が pending work（空の`childLanes`）を持たない場合、
        bailout が発生し、React はツリーのさらに下の階層に進まない
    2.  それ以外の場合、React はこの fiber を再レンダーせずに子孫に進む
2.  それ以外の場合、React はまずこの fiber を再レンダーし、その後子孫に進む

:::info
Bailout の詳細は [How does React bailout work in reconciliation](/react/2022/01/07/how-does-bailout-work/) を参照
:::

### 2.5 `memoizedProps` vs `pendingProps`

`beginWork()`では、`workInProgress`が`current`と比較されます。props については、
`workInProgress.pendingProps`と`current.memoizedProps`が比較されます。`memoizedProps`は現在の props、`pendingProps`は次のバージョンと考えることができます。

React は Render phase で新しい Fiber Tree を作成し、その後現在の Fiber Tree と比較します。`pendingProps`は実際には workInProgress の作成時のパラメータであることがわかります。

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  // ~ current is the current version
  // ~ its alternate is the version before it

  if (workInProgress === null) {
    // ~ if we have to create from scratch
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      // ~ ------------
      current.key,
      current.mode,
    );
    ...
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ~ if we can reuse the previous version
    workInProgress.pendingProps = pendingProps;
    // ~ Since we can reuse, we don't need to create Fiber Node
    // ~ But just reusing it by updating the necessary properties
    // Needed because Blocks store data on type.
    workInProgress.type = current.type;

    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.flags = NoFlags;

    // The effects are no longer valid.
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }

  // Reset all effects except static ones.
  // Static effects are not specific to a render.
  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.
  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;

  return workInProgress;
}
```

実際には、root FiberNode コンストラクタに`pendingProps`がパラメータとして存在します。

```javascript
function createFiber(
  tag: WorkTag,
  pendingProps: mixed,
  //--------------------
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
}

function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  //--------------------
  key: null | string,
  mode: TypeOfMode,
) {
  ...
}
```

これは理解できます。Fiber Node の作成は最初のステップです。後で作業する必要があります。

そして、fiber の再レンダリングが完了すると、`memoizedProps`が`pendingProps`で更新されます。これは`performUnitOfWork()`内で行われます。

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;
  setCurrentDebugFiberInDEV(unitOfWork);

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  // ~ The memoizedProps is updated after work is done
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

デモを見てみましょう。

1.  React は HostRoot（lanes: 0, childLanes: 1）を処理します。HostRoot には props がなく、
    `memoizedProps`と`pendingProps`はどちらも null であるため、React は直接子であるクローンされた`App`に進みます。
2.  React は`<App/>`（lanes: 0, childLanes: 1）を処理します。App コンポーネントは再レンダーされないため、
    `memoizedProps`と`pendingProps`は同じであるため、React は直接子であるクローンされた`div`に進みます。
3.  React は`<div/>`（lanes: 0, childLanes: 1）を処理します。この子供たちは App から来ていますが、App は再実行されないので、どの子供（`<Link>`、`<br/>`、`<Component/>`）も変更されていません。したがって、再び React は`<Link/>`に進みます。
4.  React は`<Link/>`（lanes: 0, childLanes: 0）を処理します。この時点で React はさらに下の階層に進む必要がないので、ここで停止し、兄弟である`<br/>`に進みます。
5.  React は`<br/>`（lanes: 0, childLanes: 0）を処理し、再び bailout が発生し、`<Component/>`に進みます。

ここで何かが異なっています。`<Component/>`には`lanes`が`1`あり、React はその子供を再レンダーして reconcile する必要があります。これは`updateFunctionComponent(current, workInProgress)`によって行われます。

これまでに以下の状態になりました。

![Component to be updated](https://jser.dev/static/rerender/10.avif)

### 2.6 `updateFunctionComponent()` による関数コンポーネントの再レンダーと children の reconcile

```javascript
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps: any,
  renderLanes
) {
  let context;
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let nextChildren;
  let hasId;
  prepareToReadContext(workInProgress, renderLanes);

  nextChildren = renderWithHooks(
    // ~ Here it means Component is run to generate new children
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  );

  hasId = checkDidRenderIdHook();
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  // ~ We pass down nextChildren, and reconcileChildren() is called
  return workInProgress.child;
}
```

`reconcileChildren()`は[React が初期マウントを行う方法](/2023-07-14-initial-mount/)で内部的にいくつかのバリエーションがあり、children のタイプに応じて異なります。3 つに焦点を当てます。

新しい子 fiber を作成することに加えて、既存の fiber を再利用しようとします。

```javascript
function reconcileChildFibersImpl(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  ...
  // Handle object types
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          //If just a single child
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
       ...
      case REACT_LAZY_TYPE:
        ...
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(
        //If children is an array of elements
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    ...
  }

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    return placeSingleChild(
      //if children is text
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // Remaining cases are all treated as empty.
  return deleteRemainingChildren(returnFiber, currentFirstChild);
  //-----------------------
}
```

`<Component/>`は単一の`div`を返します。したがって、`reconcileSingleElement()`に進みます。

### 2.7 `reconcileSingleElement()`

```javascript
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  //-------
  // ~ Here it is the return value of Component(), the element of `<div/>`
  lanes: Lanes,
): Fiber {
  const key = element.key;
  let child = currentFirstChild;
  while (child !== null) {
    // TODO: If key === null and child.key === null, then this only applies to
    // the first item in the list.
    if (child.key === key) {
      const elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) {
        ...
      } else {
        if (
          child.elementType === elementType ||
          // ~ If types are the same, we can reuse
          // ~ Otherwise just deleteChild()
          // Keep this check inline so it only runs on the false path:
          (__DEV__
            ? isCompatibleFamilyForHotReloading(child, element)
            : false) ||
          // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          (typeof elementType === 'object' &&
            elementType !== null &&
            elementType.$$typeof === REACT_LAZY_TYPE &&
            resolveLazy(elementType) === child.type)
        ) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          // ~ Try to use the existing fiber with new props
          // ~ element.props is the props of `<div/>`
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          return existing;
        }
      }
      // Didn't match.
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  if (element.type === REACT_FRAGMENT_TYPE) {
    ...
  } else {
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, currentFirstChild, element);
    created.return = returnFiber;
    return created;
  }
}
```

And in `useFiber`, React creates or reuse the previous version.
As mentioned before, the `pendingProps`(which contains children) will be set.

```javascript
function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {
  // We currently set sibling to null and index to 0 here because it is easy
  // to forget to do before returning it. E.g. for the single child case.
  const clone = createWorkInProgress(fiber, pendingProps);
  //-----------------------------------------
  clone.index = 0;
  clone.sibling = null;
  return clone;
}
```

So after Component is re-rendered, React goes to its child which is the new `<div/>`,
its current version has both empty `lanes` and `childLanes`.

### 2.8 Once a component is re-rendered, their subtree is re-rendered by default.

Since `<div/>` and its children don't have scheduled work, you might think bailout
happens, but it doesn't.

Remember there is a check of `memoizedProps` and `pendingProps` in `beginWork()`.

```javascript
const oldProps = current.memoizedProps;
const newProps = workInProgress.pendingProps;

if (
  oldProps !== newProps ||
  //---------------------
  hasLegacyContextChanged() ||
  // Force a re-render if the implementation changed due to hot reload:
  (__DEV__ ? workInProgress.type !== current.type : false)
) {
  // If props or context changed, mark the fiber as having performed work.
  // This may be unset if the props are determined to be equal later (memo).
  didReceiveUpdate = true;
}
```

Notice that shallow equal is not used in comparing the props,
while every time a component is rendered, it generates a brand new object
containing React elements, so `pendingProps` will be newly created every time.

For `<div/>`, once `Component()` is run, it always gets new props so bailout won't happen at all.

Thus React goes to update branch - `updateHostComponent()`.

### 2.9 `updateHostComponent()`

```javascript


Props : null;

  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  //---------------------------------------------------------------------
  return workInProgress.child;
}
```

`nextChildren` here is:

```javascript
[
  { $$typeof: Symbol(react.element), type: "button" },
  " (",
  { $$typeof: Symbol(react.element), type: "b" },
  ")",
];
```

So internally React reconciles it with `reconcileChildrenArray()`.

And `memoizedProps` of `current` is.

```javascript
[
  { $$typeof: Symbol(react.element), type: "button" },
  " (",
  { $$typeof: Symbol(react.element), type: "span" },
  ")",
];
```

### 2.10 `reconcileChildrenArray()` creates and deletes fibers as needed.

`reconcileChildrenArray()` is a bit complex. It does extra optimization
by checking if there is re-ordering of element and tries to reuse fibers
if `key` exists.

For `key`, I have a separate episode for this topic - [How does 'key' work internally? List diffing in React](/react/2022/02/08/the-diffing-algorithm-for-array-in-react/).

But in our demo, we don't have `key`, so we'll just go to the base branch.

```javascript
function reconcileChildrenArray(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChildren: Array,
    lanes: Lanes,
  ): Fiber | null {
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;

    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      //Check current fibers against the children elements
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        //Here each fiber in the list is checked upon with new props
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // ~ If a fiber cannot be reused, it will be marked as Deletion
          // ~ which in commit phase, its DOM node is deleted
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
          //-----------
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      // ~ This tries to mark the fiber as Insertion
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    ...

    return resultingFirstChild;
  }
```

`updateSlot()` basically just creates or reuse fibers with new props, with consideration of `key`.

```javascript
function updateSlot(
  returnFiber: Fiber,
  oldFiber: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // Update the fiber if the keys match, otherwise return null.
  const key = oldFiber !== null ? oldFiber.key : null;

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    // Text nodes don't have keys. If the previous node is implicitly keyed
    // we can continue to replace it without aborting even if it is not a text
    // node.
    if (key !== null) {
      return null;
    }
    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
  }

  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE: {
        if (newChild.key === key) {
          return updateElement(returnFiber, oldFiber, newChild, lanes);
        //-------------
        } else {
          return null;
        }
      }
      ...
    }
  }

  return null;
}

function updateElement(
  returnFiber: Fiber,
  current: Fiber | null,
  element: ReactElement,
  lanes: Lanes,
): Fiber {
  const elementType = element.type;
  if (elementType === REACT_FRAGMENT_TYPE) {
    return updateFragment(
      returnFiber,
      current,
      element.props.children,
      lanes,
      element.key,
    );
  }
  if (current !== null) {
    if (
      current.elementType === elementType ||
      //-----------------------------------
      // Keep this check inline so it only runs on the false path:
      (__DEV__
        ? isCompatibleFamilyForHotReloading(current, element)
        : false) ||
      // Lazy types should reconcile their resolved type.
      // We need to do this after the Hot Reloading check above,
      // because hot reloading has different semantics than prod because
      // it doesn't resuspend. So we can't let the call below suspend.
      (typeof elementType === 'object' &&
        elementType !== null &&
        elementType.$$typeof === REACT_LAZY_TYPE &&
        resolveLazy(elementType) === current.type)
    ) {
      // Move based on index
      const existing = useFiber(current, element.props);
       //--------
      existing.ref = coerceRef(returnFiber, current, element);
      existing.return = returnFiber;
      return existing;
    }
  }
  // Insert
  const created = createFiberFromElement(element, returnFiber.mode, lanes);
  //----------------------
  created.ref = coerceRef(returnFiber, current, element);
  created.return = returnFiber;
  return created;
}
```

So for `<div/>`,`updateSlot()` successfully reused 3 children, except the 3th one because
`current` is `span` but we want `b`, thus fiber of `b` is created from scratch and
fiber of `span` is deleted by `deleteChild()`. The newly created `b` is marked by `placeChild()`.

### 2.11 `placeChild()` and `deleteChild()` marks fiber with flags

Ok, for the children of `<div>` under `Component`, we have these 2 functions
that marks fiber nodes.

```javascript
function placeChild(
  newFiber: Fiber,
  lastPlacedIndex: number,
  newIndex: number
): number {
  newFiber.index = newIndex;
  if (!shouldTrackSideEffects) {
    // During hydration, the useId algorithm needs to know which fibers are
    // part of a list of children (arrays, iterators).
    newFiber.flags |= Forked;
    return lastPlacedIndex;
  }
  const current = newFiber.alternate;
  if (current !== null) {
    const oldIndex = current.index;
    if (oldIndex < lastPlacedIndex) {
      // This is a move.
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    } else {
      // This item can stay in place.
      return oldIndex;
    }
  } else {
    // This is an insertion.
    newFiber.flags |= Placement;
    return lastPlacedIndex;
  }
}
```

```javascript
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
  if (!shouldTrackSideEffects) {
    // Noop.
    return;
  }
  const deletions = returnFiber.deletions;
  if (deletions === null) {
    returnFiber.deletions = [childToDelete];
    returnFiber.flags |= ChildDeletion;
  } else {
    deletions.push(childToDelete);
  }
}
```

We see that fibers that should be deleted are put temporarily in an array of its parent.
This is needed because they don't exist in the new fiber tree any longer after deletion,
but they are to be processed in Commit phase, so we need to put them somewhere.

Ok we are done with `<div>`.

![End of Div Processing](https://jser.dev/static/rerender/13.avif)

Next React goes to `button`. Again, thought it doesn't have any schedule work,
React still works on it with `updateHostComponent()` because props have changed
from `["click me-", "1"]` to `["click me-", "2"]`.

For HostText their props are string, so the first `"click me -"` bails out.
And in turn, React tries to reconcile the texts with `updateHostText()`.

### 2.12 `updateHostText()`

```javascript
function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}
```

Again it doesn't nothing, because the updates are marked in complete phase - `completeWork()`.
This is also explained in [initial mount](/2023-07-14-initial-mount/#313-dom-nodes-are-created-offscreen-in-completework).

### 2.13 `completeWork()` marks the update of HostComponent and creates DOM nodes if necessary

```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  // Note: This intentionally doesn't check if we're hydrating because comparing
  // to the current tree provider fiber is just as fast and less error-prone.
  // Ideally we would have a special version of the work loop only
  // for hydration.
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);
      return null;
    case HostComponent: {
      popHostContext(workInProgress);
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      if (current !== null && workInProgress.stateNode != null) {
        //This is update branch we are having
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          rootContainerInstance,
        );

        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
      //This is the initial mount branch we overed in [previous episode](/2023-07-14-initial-mount)
        ...
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case HostText: {
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
       //This is update branch we are having
        const oldText = current.memoizedProps;
        // If we have an alternate, that means this is an update and we need
        // to schedule a side-effect to do the updates.
        updateHostText(current, workInProgress, oldText, newText);
      } else {
      //This is the initial mount branch we overed in [previous episode](/2023-07-14-initial-mount)
        ...
        if (wasHydrated) {
          if (prepareToHydrateHostTextInstance(workInProgress)) {
            markUpdate(workInProgress);
          }
        } else {
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    ...
  }
}
```

```javascript
updateHostText = function (
  //Notice this is a different `updateHostText()` in complete phase
  current: Fiber,
  workInProgress: Fiber,
  oldText: string,
  newText: string
) {
  // If the text differs, mark it as an update. All the work in done in commitWork.
  if (oldText !== newText) {
    markUpdate(workInProgress);
    //--------
  }
};

updateHostComponent = function (
  current: Fiber,
  workInProgress: Fiber,
  type: Type,
  newProps: Props,
  rootContainerInstance: Container
) {
  // If we have an alternate, that means this is an update and we need to
  // schedule a side-effect to do the updates.
  const oldProps = current.memoizedProps;
  if (oldProps === newProps) {
    // In mutation mode, this is sufficient for a bailout because
    // we won't touch this node even if children changed.
    return;
  }

  // If we get updated because one of our children updated, we don't
  // have newProps so we'll have to reuse them.
  // TODO: Split the update API as separate for the props vs. children.
  // Even better would be if children weren't special cased at all tho.
  const instance: Instance = workInProgress.stateNode;
  const currentHostContext = getHostContext();
  // TODO: Experiencing an error where oldProps is null. Suggests a host
  // component is hitting the resume path. Figure out why. Possibly
  // related to `hidden`.
  const updatePayload: null | UpdatePayload = prepareUpdate(
    instance,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
    currentHostContext
  );
  // TODO: Type this specific to this type of component.
  workInProgress.updateQueue = (updatePayload: any);
  //----------
  //the update is put in updateQueue
  // ~ This actually is also used for hooks like [Effect Hooks](/2023-07-08-how-does-useeffect-work/)

  // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update. All the work is done in commitWork.
  if (updatePayload) {
    markUpdate(workInProgress);
    //----------
  }
};

function markUpdate(workInProgress: Fiber) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
  //---------------
  // ~ Yep, another flag!
}
```

So we are done with the Render phase and here we got

1.  an Insertion on `b`
2.  a Deletion on `span`
3.  an update on HostText
4.  an update on `button` (empty under the hood).

One thing I'd like to point out is that `prepareUpdate()` is run for both `button` and its parent `div`,
yet it generates `null` for `div` but `[]` for `button`. It is some tricky edge case handling
that we won't dive into here.

![Fiber Tree Render Phase End](https://jser.dev/static/rerender/25.avif)

It's time to commit these updates in Commit phase.

## 3. Re-render in Commit Phase

### 3.1 `commitMutationEffectsOnFiber()` kicks off the commit of Insertion/Deletion/Update

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      //----------------------------------
      // ~ Recursively handles children First
      commitReconciliationEffects(finishedWork);
      //----------------------------------
      // ~ Then Insertion
      if (flags & Update) {
        //--------------------
        //Update at last
        try {
          commitHookEffectListUnmount(
            HookInsertion | HookHasEffect,
            finishedWork,
            finishedWork.return,
          );
          commitHookEffectListMount(
            HookInsertion | HookHasEffect,
            finishedWork,
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        ...
      }
      return;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      //----------------------------------
      // ~ Recursively handles children First
      commitReconciliationEffects(finishedWork);
      //----------------------------------
      // ~ Then Insertion

      if (supportsMutation) {
        // TODO: ContentReset gets cleared by the children during the commit
        // phase. This is a refactor hazard because it means we must read
        // flags the flags after `commitReconciliationEffects` has already run;
        // the order matters. We should refactor so that ContentReset does not
        // rely on mutating the flag during commit. Like by setting a flag
        // during the render phase instead.
        if (finishedWork.flags & ContentReset) {
          const instance: Instance = finishedWork.stateNode;
          try {
            resetTextContent(instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }

        if (flags & Update) {
          //--------------------
          //Update at last
          const instance: Instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            const newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            const oldProps =
              current !== null ? current.memoizedProps : newProps;
            const type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              try {
                commitUpdate(
                  //------------
                  instance,
                  updatePayload,
                  type,
                  oldProps,
                  newProps,
                  finishedWork,
                );
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error,
                );
              }
            }
          }
        }
      }
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        if (supportsMutation) {
          if (finishedWork.stateNode === null) {
            throw new Error(
              'This should have a text node initialized. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }

          const textInstance: TextInstance = finishedWork.stateNode;
          const newText: string = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          const oldText: string =
            current !== null ? current.memoizedProps : newText;

          try {
            commitTextUpdate(textInstance, oldText, newText);
              //----------------
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    ...
  }
}
```

We can see that it is a recursive process and let's take a closer look at each
type of mutation.

### 3.2 Deletion are processed first, before processing children and self.

```javascript
function recursivelyTraverseMutationEffects(
  root: FiberRoot,
  parentFiber: Fiber,
  lanes: Lanes
) {
  // Deletions effects can be scheduled on any fiber type. They need to happen
  // before the children effects hae fired.
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      try {
        commitDeletionEffects(root, parentFiber, childToDelete);
        //---------------------
      } catch (error) {
        captureCommitPhaseError(childToDelete, parentFiber, error);
      }
    }
  }

  const prevDebugFiber = getCurrentDebugFiberInDEV();
  if (parentFiber.subtreeFlags & MutationMask) {
    let child = parentFiber.child;
    while (child !== null) {
      setCurrentDebugFiberInDEV(child);
      commitMutationEffectsOnFiber(child, root, lanes);
      //----------------------------
      child = child.sibling;
    }
  }
  setCurrentDebugFiberInDEV(prevDebugFiber);
}
```

Deletions are processed first, even before processing children.

```javascript
function commitDeletionEffects(
  root: FiberRoot,
  returnFiber: Fiber,
  deletedFiber: Fiber
) {
  if (supportsMutation) {
    // We only have the top Fiber that was deleted but we need to recurse down its
    // children to find all the terminal nodes.

    // Recursively delete all host nodes from the parent, detach refs, clean
    // up mounted layout effects, and call componentWillUnmount.

    // We only need to remove the topmost host child in each branch. But then we
    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We
    // could split this into two separate traversals functions, where the second
    // one doesn't include any removeChild logic. This is maybe the same
    // function as "disappearLayoutEffects" (or whatever that turns into after
    // the layout phase is refactored to use recursion).

    // Before starting, find the nearest host parent on the stack so we know
    // which instance/container to remove the children from.
    // TODO: Instead of searching up the fiber return path on every deletion, we
    // can track the nearest host component on the JS stack as we traverse the
    // tree during the commit phase. This would make insertions faster, too.
    let parent = returnFiber;
    findParent: while (parent !== null) {
      //--------------------------------
      //Since parent node doesn't necessary means it has backing DOM
      //Here it searches for the closest Fiber Node that has backingDOM
      switch (parent.tag) {
        case HostComponent: {
          hostParent = parent.stateNode;
          hostParentIsContainer = false;
          break findParent;
        }
        case HostRoot: {
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = true;
          break findParent;
        }
        case HostPortal: {
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = true;
          break findParent;
        }
      }
      parent = parent.return;
    }
    if (hostParent === null) {
      throw new Error(
        "Expected to find a host parent. This error is likely caused by " +
          "a bug in React. Please file an issue."
      );
    }
    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
    //----------------------------
    hostParent = null;
    hostParentIsContainer = false;
  } else {
    // Detach refs and call componentWillUnmount() on the whole subtree.
    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
    //----------------------------
  }

  detachFiberMutation(deletedFiber);
}
```

### 3.3 Insertions are processed next

This is so that newly created nodes could be set up in a tree structure.

```javascript
function commitReconciliationEffects(finishedWork: Fiber) {
  // Placement effects (insertions, reorders) can be scheduled on any fiber
  // type. They needs to happen after the children effects have fired, but
  // before the effects on this fiber have fired.
  const flags = finishedWork.flags;
  if (flags & Placement) {
    try {
      commitPlacement(finishedWork);
      //---------------
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    // Clear the "placement" from effect tag so that we know that this is
    // inserted, before any life-cycles like componentDidMount gets called.
    // TODO: findDOMNode doesn't rely on this any more but isMounted does
    // and isMounted is deprecated anyway so we should be able to kill this.
    finishedWork.flags &= ~Placement;
  }
  if (flags & Hydrating) {
    finishedWork.flags &= ~Hydrating;
  }
}

function commitPlacement(finishedWork: Fiber): void {
  if (!supportsMutation) {
    return;
  }

  // Recursively insert all host nodes into the parent.
  const parentFiber = getHostParentFiber(finishedWork);

  // Note: these two variables *must* always be updated together.
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent: Instance = parentFiber.stateNode;
      if (parentFiber.flags & ContentReset) {
        // Reset the text content of the parent before doing any insertions
        resetTextContent(parent);
        // Clear ContentReset from the effect tag
        parentFiber.flags &= ~ContentReset;
      }

      const before = getHostSibling(finishedWork);
      // ~ This is important. [Node.insertBefore()](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) needs the sibling node
      // ~ If we cannot find it, then we just append it to the end
      // We only have the top Fiber that was inserted but we need to recurse down its
      // children to find all the terminal nodes.
      insertOrAppendPlacementNode(finishedWork, before, parent);
      //---------------------------
      break;
    }
    case HostRoot:
    case HostPortal: {
      const parent: Container = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
      break;
    }
    // eslint-disable-next-line-no-fallthrough
    default:
      throw new Error(
        "Invalid host parent fiber. This error is likely caused by a bug " +
          "in React. Please file an issue."
      );
  }
}

function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode: Instance = node.stateNode;
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
  } else {
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(
  node: Fiber,
  before: ?Instance,
  parent: Instance
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode: Instance = node.stateNode;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
  } else {
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
```

### 3.4 Updates are handled at last

Update branch is inside `commitMutationEffectsOnFiber()`.

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        //For FunctionComponent, this means hooks need to be run
        try {
          commitHookEffectListUnmount(
            HookInsertion | HookHasEffect,
            finishedWork,
            finishedWork.return,
          );
          commitHookEffectListMount(
            HookInsertion | HookHasEffect,
            finishedWork,
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        if (
          enableProfilerTimer &&
          enableProfilerCommitHooks &&
          finishedWork.mode & ProfileMode
        ) {
          try {
            startLayoutEffectTimer();
            commitHookEffectListUnmount(
              HookLayout | HookHasEffect,
              finishedWork,
              finishedWork.return,
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          recordLayoutEffectDuration(finishedWork);
        } else {
          try {
            commitHookEffectListUnmount(
              HookLayout | HookHasEffect,
              finishedWork,
              finishedWork.return,
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Ref) {
        if (current !== null) {
          safelyDetachRef(current, current.return);
        }
      }
      if (supportsMutation) {
        // TODO: ContentReset gets cleared by the children during the commit
        // phase. This is a refactor hazard because it means we must read
        // flags the flags after `commitReconciliationEffects` has already run;
        // the order matters. We should refactor so that ContentReset does not
        // rely on mutating the flag during commit. Like by setting a flag
        // during the render phase instead.
        if (finishedWork.flags & ContentReset) {
          const instance: Instance = finishedWork.stateNode;
          try {
            resetTextContent(instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }

        if (flags & Update) {
          //For HostComponent, this means element attributes are needed to be updated
          const instance: Instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            const newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            const oldProps =
              current !== null ? current.memoizedProps : newProps;
            const type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              try {
                commitUpdate(
                  //------------
                  instance,
                  updatePayload,
                  type,
                  oldProps,
                  newProps,
                  finishedWork,
                );
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error,
                );
              }
            }
          }
        }
      }
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        if (supportsMutation) {
          if (finishedWork.stateNode === null) {
            throw new Error(
              'This should have a text node initialized. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }

          const textInstance: TextInstance = finishedWork.stateNode;
          const newText: string = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          const oldText: string =
            current !== null ? current.memoizedProps : newText;

          try {
            commitTextUpdate(textInstance, oldText, newText);
              //----------------
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    ...
  }
}
```

```javascript
export function commitUpdate(
  domElement: Instance,
  updatePayload: Array<mixed>,
  type: string,
  oldProps: Props,
  newProps: Props,
  internalInstanceHandle: Object
): void {
  // Apply the diff to the DOM node.
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
  //----------------
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps);
}

export function commitTextUpdate(
  textInstance: TextInstance,
  oldText: string,
  newText: string
): void {
  textInstance.nodeValue = newText;
}
```

So we are done with the Render phase and here we got

1.  an Insertion on `b`
2.  a Deletion on `span`
3.  an update on HostText
4.  an update on `button` (empty under the hood).

One thing I'd like to point out is that `prepareUpdate()` is run for both `button` and its parent `div`,
yet it generates `null` for `div` but `[]` for `button`. It is some tricky edge case handling
that we won't dive into here.

![End Result of Re-render](https://jser.dev/static/rerender/25.avif)

It's time to commit these updates in Commit phase.

## 4. Summary

Phew that is a lot. I'd roughly summarize the re-render process as below.

1.  After state changes, paths to target Fiber Node are marked with `lanes` and `childLanes`,
    to indicate if they or their subtree need to be re-rendered.
2.  React re-render the whole Fiber Tree, with optimization of bailout to avoid re-rendering
    unnecessarily.
3.  Once a component re-renders, it generates new React elements, its children all get
    new props even though they are equal, so React re-renders the whole Fiber Tree by default.
    Here is why you might need `useMemo()`.
4.  By "re-render", React creates a new Fiber Tree out of current one, also marks the Fiber
    Node with flags of `Placement` `ChildDeletion` and `Update` if needed.
5.  Once the new Fiber Tree is done, React processes Fiber Nodes with above flags and apply
    the changes to Host DOM in Commit phase.
6.  Then the new Fiber Tree is pointed to as the current Fiber Tree. The nodes on previous Fiber Tree
    could be reused for next render.

I've put the steps into slides below, hope it helps.

Want to know more about how React works internally?
Check out my series - **React Internals Deep Dive**!
