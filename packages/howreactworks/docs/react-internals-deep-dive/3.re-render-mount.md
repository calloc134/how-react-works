---
title: React の再レンダリングの内部動作
---

# React は内部的にどのように再レンダーするのか？

:::info
[React Internals Deep Dive](/series/react-source-code-walkthrough.html) シリーズのエピソード 3。[Youtube で解説しています](https://www.youtube.com/watch?v=0GM-1W7i9Tk&list=PLvx8w9g4qv_p-OS-XdbB3Ux_6DMXhAJC3&index=3)
:::

:::warning
[React@18.2.0](https://github.com/facebook/react/releases/tag/v18.2.0) ベース。新しいバージョンでは実装が変更されている可能性があります
:::

[初期マウント時の React の動作](/2023-07-14-initial-mount/)について説明しました。初期マウント後、React は reconciliation プロセスを通じて DOM を可能な限り再利用しようとします。このエピソードでは、デモのボタンクリック後の再レンダー処理の内部動作を解説します。

デモは前回のエピソードとは異なります。[こちらで試すことができます](/demos/react/overview/re-render.html)。

## 目次

- [1. トリガーフェーズでの再レンダー](#1-re-render-in-trigger-phase)
  - [1.1 `lanes` と `childLanes`](#11-lanes-and-childlanes)
- [2. レンダーフェーズでの再レンダー](#2-re-render-in-render-phase)
  - [2.1 基本的なレンダリングロジックは初期マウント時と同じ](#21-basic-rendering-logic-is-the-same-as-initial-mount)
  - [2.2 React は新しい Fiber Node 作成前に既存のものを再利用](#22-react-reuses-redundant-fiber-nodes-before-creating-new-ones)
  - [2.3 `beginWork()` の Update ブランチ](#23-the-update-branch-in-beginwork)
  - [2.4 `attemptEarlyBailoutIfNoScheduledUpdate()` 内の Bailout ロジック](#24-bailout-logic-inside-attemptearlybailoutifnoscheduledupdate)
  - [2.5 `memoizedProps` vs `pendingProps`](#25-memoizedprops-vs-pendingprops)
  - [2.6 `updateFunctionComponent()` による関数コンポーネントの再レンダーと children の reconcile](#26-updatefunctioncomponent-re-renders-function-components-and-reconcile-children)
  - [2.7 `reconcileSingleElement()` による単一要素の調整](#27-reconcilesingleelement)
  - [2.8 コンポーネントが再レンダーされると、そのサブツリーはデフォルトで再レンダーされる](#28-once-a-component-is-re-rendered-their-subtree-is-re-rendered-by-default)
  - [2.9 `updateHostComponent()` によるホストコンポーネントの更新](#29-updatehostcomponent)
  - [2.10 `reconcileChildrenArray()` が必要に応じて fiber を作成・削除](#210-reconcilechildrenarray-creates-and-deletes-fibers-as-needed)
  - [2.11 `placeChild()` と `deleteChild()` による Fiber フラグのマーキング](#211-placechild-and-deletechild-marks-fiber-with-flags)
  - [2.12 `updateHostText()` によるテキストノードの更新](#212-updatehosttext)
  - [2.13 `completeWork()` による HostComponent の更新マーキングと DOM ノード作成](#213-completework-marks-the-update-of-hostcomponent-and-creates-dom-nodes-if-necessary)
- [3. コミットフェーズでの再レンダー](#3-re-render-in-commit-phase)
  - [3.1 `commitMutationEffectsOnFiber()` による挿入/削除/更新の開始](#31-commitmutationeffectsonfiber-kicks-off-the-commit-of-insertiondeletionupdate)
  - [3.2 削除処理は子要素と自身の処理前に最初に実行](#32-deletion-are-processed-first-before-processing-children-and-self)
  - [3.3 次に挿入処理が実行](#33-insertions-are-processed-next)
  - [3.4 更新処理は最後に処理](#34-updates-are-handled-at-last)
- [4. まとめ](#4-summary)

## 1. トリガーフェーズの再レンダー

React は[初期マウント](/2023-07-14-initial-mount/)で Fiber Tree と DOM ツリーを構築します。完了したとき、以下の 2 つのツリーが存在します。

![Fiber Tree Initial](https://jser.dev/static/rerender/1.avif)

### 1.1 `lanes` と `childLanes`

Lane は保留中の work の優先度を表します。Fiber Node は以下を持ちます:

1. `lanes` => 自身の保留中の work 用
2. `childLanes` => サブツリーの保留中の work 用

:::info
Lanes の詳細は [What are Lanes in React source code](/react/2022/03/26/lanes-in-react/) を参照
:::

ボタンがクリックされると`setState()`が呼び出されます:

1. root からターゲット fiber までのパスに`lanes`と`childLanes`がマークされ、次回のレンダーでチェックが必要な箇所を示す
2. `scheduleUpdateOnFiber()`によってアップデートがスケジュールされ、最終的に`ensureRootIsScheduled()`が呼び出されて
   Scheduler に`performConcurrentWorkOnRoot()`が登録されます。これは[初期マウント](/2023-07-14-initial-mount/)と同様のプロセスです。

重要な点は、イベントの優先度がアップデートの優先度を決定することです。`click`イベントは`DiscreteEventPriority`であり、`SyncLane`（高優先度）にマッピングされます。

:::info
`useState()`の動作詳細は [How does useState() work internally in React](/2023-06-19-how-does-usestate-work) を参照
:::

詳細は割愛しますが、最終的に作業対象となる以下の Fiber Tree が得られます。

![Fiber Tree Lanes](https://jser.dev/static/rerender/2.avif)

## 2. レンダーフェーズでの再レンダー

### 2.1 基本的なレンダリングロジックは初期マウント時と同じ

`click`イベントの場合、レンダーレーンは SyncLane であり、これはブロッキングレーンです。
したがって、初期マウントと同様に、`performConcurrentWorkOnRoot()`内で concurrent mode はまだ有効になっていません。

:::info
concurrent mode が有効になっている場合は、[How does useTransition() work internally in React?](/2023-05-19-how-does-usetransition-work/)を参照
:::

以下は全体のプロセスをまとめたコードです。

```javascript
do {
  try {
    workLoopSync();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;

  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  // ~ この行は重要です。[2.5 memoizedProps vs pendingProps](#25-memoizedprops-vs-pendingprops)で説明します
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // 新しいworkが生成されない場合、現在のworkを完了
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

詳細な説明については、[前回のエピソード](/2023-07-14-initial-mount/#32-renderrootsync)を参照してください。
ここでは、React が Fiber Tree をトラバースし、必要に応じて fiber を更新することを覚えておいてください。

### 2.2 React は新しい Fiber Node 作成前に既存のものを再利用

[初期マウント](/2023-07-14-initial-mount/)では、Fiber がスクラッチから作成されます。
しかし実際には、React は最初に Fiber Node を再利用しようとします。

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  // ~ currentは現在のバージョン
  // ~ alternateは以前のバージョンを指す

  if (workInProgress === null) {
    // ~ 最初から作成する必要がある場合
    // ツリーのバージョンは最大でも 2 つしか必要ないことがわかっているため、
    // ダブル バッファリングのプーリング手法を使用します。
    // ここで、再利用できる「その他の」未使用ノードをプールします。
    // 更新されないものに対して余分なオブジェクトを割り当てないように、遅延して作成されます。
    // また、必要に応じて余分なメモリを再利用することもできます。
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      // ~ ------
      current.key,
      current.mode,
    );
    ...
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ~ 前のバージョンを再利用可能な場合
    workInProgress.pendingProps = pendingProps;
    // ~ 再利用可能なため、新しいFiber Nodeを作成する必要はありません
    // ~ 代わりに必要なプロパティを更新して再利用します
    // Blocksがtypeにデータを保存するため必要
    workInProgress.type = current.type;

    // alternateは既に存在
    // effect tagをリセット
    workInProgress.flags = NoFlags;

    // エフェクトは無効化
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }

  // 静的エフェクト以外をリセット
  // 静的エフェクトは特定のレンダーに紐づきません
  workInProgress.flags = current.flags & StaticMask;
  // ~ lanesとchildLanesをコピー
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;


  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  ...
  return workInProgress;
}
```

`current`が Fiber Tree 上にないすべての Fiber Node は再利用できます。

再レンダープロセスでは、冗長な`HostRoot`は`prepareFreshStack()`で再利用されます。

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  ...
  workInProgressRoot = root;
  // ~ ルートの`current`はHostRootのFiberNodeです
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  finishQueueingConcurrentUpdates();
  return rootWorkInProgress;
}
```

したがって、再レンダリングを以下のヘッドから開始します。

![Starting Point](https://jser.dev/static/rerender/3.avif)

色を付けてみましょう。

![Starting Point Colored](https://jser.dev/static/rerender/4.avif)

### 2.3 `beginWork()` の Update ブランチ

`beginWork()`内には、更新を処理する重要なブランチがあります。
このブランチは、初期マウントのエピソードでは扱いませんでした。

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (current !== null) {
    // ~ currentがnullでない場合、初期マウントではなく
    // ~ 以前のバージョンのFiber NodeとDOMノード（HostComponentの場合）が存在する
    // ~ これによりReactはサブツリーの深い処理をスキップ（bailout）して最適化可能
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (
      oldProps !== newProps ||
      // ~ ここではshallow equalではなく`===`を使用
      // ~ これがReactレンダリングの重要な挙動につながる
      hasLegacyContextChanged() ||
      // ホットリロードによる実装変更時は強制再レンダー
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // propsまたはcontextが変更された場合、workを実行済みとしてマーク
      // memo化された場合は後で解除される可能性あり
      didReceiveUpdate = true;
    } else {
      // propsもlegacy contextも変更なし。保留中の更新または
      // context変更をチェック
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        // ~ fiberの`lanes`をチェック
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        // エラーやサスペンス境界の2回目のパスでは
        // `current`にスケジュールされたworkがない可能性あり
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // 保留中の更新やcontextなし。即時bailout
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          // ~ このfiberに更新がない場合、Reactはbailoutを試みる
          // ~ propsやcontext変更がない場合のみ
          current,
          workInProgress,
          renderLanes,
        );
      }
     ...
    }
  } else {
    didReceiveUpdate = false;
    // ~ これは以前説明したマウント時のブランチ
    ...
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        //------------------------
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    //--------------
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    //-------------------
    case HostText:
      return updateHostText(current, workInProgress);
    //--------------
    ...
  }

}
```

### 2.4 `attemptEarlyBailoutIfNoScheduledUpdate()` 内の Bailout ロジック

この関数は、不要な場合はできるだけ早くレンダリングを停止しようとします。

```javascript
function attemptEarlyBailoutIfNoScheduledUpdate(
  current: Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  // このfiberには保留中のworkがありません。beginフェーズに入らずにbailout
  // 最適化されたパスでもいくつかの管理作業が必要です（主にスタックへのプッシュ）
  switch (workInProgress.tag) {
    case HostRoot:
      pushHostRootContext(workInProgress);
      const root: FiberRoot = workInProgress.stateNode;
      pushRootTransition(workInProgress, root, renderLanes);

      if (enableCache) {
        const cache: Cache = current.memoizedState.cache;
        pushCacheProvider(workInProgress, cache);
      }
      resetHydrationState();
      break;
    case HostComponent:
      pushHostContext(workInProgress);
      break;
    ...
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  //----------------------------
}
```

```javascript
function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  if (current !== null) {
    // 以前の依存関係を再利用
    workInProgress.dependencies = current.dependencies;
  }

  // 子要素に保留中のworkがあるかチェック
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // ~ ここで`childLanes`がチェックされる
    // 子要素にもworkがない場合、処理をスキップ可能
    // TODO: 再開機能を追加する際、子要素がwork-in-progressセットか確認が必要

    if (enableLazyContextPropagation && current !== null) {
      // bailout前に子要素のcontext変更をチェック
      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);
      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
        return null;
        // ~ fiber自身とサブツリーに更新がない場合
        // ~ ツリーの深い階層への進行を停止
      }
    } else {
      return null;
      // ~ fiber自身とサブツリーに更新がない場合
      // ~ ツリーの深い階層への進行を停止
    }
  }

  // このfiberにworkはないがサブツリーには存在する場合
  // 子fiberをクローンして処理継続
  cloneChildFibers(current, workInProgress);
  // ~ "clone"と名前が付いているが、実際には新しい子ノードを作成するか
  // ~ 以前のノードを再利用する
  return workInProgress.child;
  // ~ 子fiberを直接返し、Reactは次のfiberとして処理を続行
  // ~ 詳細は [Reactが内部的にFiberツリーをトラバースする方法](/react/2022/01/16/fiber-traversal-in-react/) を参照
}

export function cloneChildFibers(
  current: Fiber | null,
  workInProgress: Fiber
): void {
  if (current !== null && workInProgress.child !== current.child) {
    throw new Error("Resuming work not yet implemented.");
  }

  if (workInProgress.child === null) {
    return;
  }

  let currentChild = workInProgress.child;
  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  // ~ cloneChildFibers()内では、子fiberは以前のバージョンから作成されます
  // ~ ただしreconciliation中に設定された新しいpendingPropsが適用されます
  workInProgress.child = newChild;
  newChild.return = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(
      currentChild,
      currentChild.pendingProps
    );
    newChild.return = workInProgress;
  }
  newChild.sibling = null;
}
```

Bailout プロセスをまとめると以下のようになります

1.  fiber が props/context の変更を持たず、かつ pending work（空の`lanes`）がない場合
    1.  子孫が pending work（空の`childLanes`）を持たない場合、
        bailout が発生し、React はツリーのさらに下の階層に進まない
    2.  それ以外の場合、React はこの fiber を再レンダーせずに子孫に進む
2.  それ以外の場合、React はまずこの fiber を再レンダーし、その後子孫に進む

:::info
Bailout の詳細は [How does React bailout work in reconciliation](/react/2022/01/07/how-does-bailout-work/) を参照
:::

### 2.5 `memoizedProps` vs `pendingProps`

`beginWork()`では、`workInProgress`が`current`と比較されます。props については、
`workInProgress.pendingProps`と`current.memoizedProps`が比較されます。`memoizedProps`は現在の props、`pendingProps`は次のバージョンと考えることができます。

React は Render phase で新しい Fiber Tree を作成し、その後現在の Fiber Tree と比較します。`pendingProps`は実際には workInProgress の作成時のパラメータであることがわかります。

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  // ~ currentは現在のバージョン
  // ~ alternateは以前のバージョンを指す

  if (workInProgress === null) {
    // ~ 最初から作成する必要がある場合
    // ツリーのバージョンは最大でも 2 つしか必要ないことがわかっているため、
    // ダブル バッファリングのプーリング手法を使用します。
    // ここで、再利用できる「その他の」未使用ノードをプールします。
    // 更新されないものに対して余分なオブジェクトを割り当てないように、遅延して作成されます。
    // また、必要に応じて余分なメモリを再利用することもできます。
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      // ~ ------------
      current.key,
      current.mode,
    );
    ...
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // ~ 前のバージョンを再利用可能な場合
    workInProgress.pendingProps = pendingProps;
    // ~ 再利用可能なため、新しいFiber Nodeを作成する必要はありません
    // ~ 代わりに必要なプロパティを更新して再利用します
    // Blocksがtypeにデータを保存するため必要
    workInProgress.type = current.type;

    // alternateは既に存在
    // effect tagをリセット
    workInProgress.flags = NoFlags;

    // エフェクトは無効化
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }

  // 静的エフェクト以外をリセット
  // 静的エフェクトは特定のレンダーに紐づきません
  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // 依存関係オブジェクトをクローン（レンダーフェーズで変更され、共有ができないため）
  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  // 親のreconciliation処理で上書きされるプロパティ
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;

  return workInProgress;
}
```

実際には、root FiberNode コンストラクタに`pendingProps`がパラメータとして存在します。

```javascript
function createFiber(
  tag: WorkTag,
  pendingProps: mixed,
  //--------------------
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  // $FlowFixMe[incompatible-call]: 形状は正しいが、Flow はコンストラクタを好まない
  return new FiberNode(tag, pendingProps, key, mode);
}

function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  //--------------------
  key: null | string,
  mode: TypeOfMode,
) {
  ...
}
```

これは理解できます。Fiber Node の作成は最初のステップです。後で作業する必要があります。

そして、fiber の再レンダリングが完了すると、`memoizedProps`が`pendingProps`で更新されます。これは`performUnitOfWork()`内で行われます。

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;
  setCurrentDebugFiberInDEV(unitOfWork);

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  // ~ memoizedPropsはworkが完了した後に更新されます
  if (next === null) {
    // ~ 新しいworkが生成されない場合、現在のworkを完了
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

デモを見てみましょう。

1.  React は HostRoot（lanes: 0, childLanes: 1）を処理します。HostRoot には props がなく、
    `memoizedProps`と`pendingProps`はどちらも null であるため、React は直接子であるクローンされた`App`に進みます。
2.  React は`<App/>`（lanes: 0, childLanes: 1）を処理します。App コンポーネントは再レンダーされないため、
    `memoizedProps`と`pendingProps`は同じであるため、React は直接子であるクローンされた`div`に進みます。
3.  React は`<div/>`（lanes: 0, childLanes: 1）を処理します。この子供たちは App から来ていますが、App は再実行されないので、どの子供（`<Link>`、`<br/>`、`<Component/>`）も変更されていません。したがって、再び React は`<Link/>`に進みます。
4.  React は`<Link/>`（lanes: 0, childLanes: 0）を処理します。この時点で React はさらに下の階層に進む必要がないので、ここで停止し、兄弟である`<br/>`に進みます。
5.  React は`<br/>`（lanes: 0, childLanes: 0）を処理し、再び bailout が発生し、`<Component/>`に進みます。

ここで何かが異なっています。`<Component/>`には`lanes`が`1`あり、React はその子供を再レンダーして reconcile する必要があります。これは`updateFunctionComponent(current, workInProgress)`によって行われます。

これまでに以下の状態になりました。

![Component to be updated](https://jser.dev/static/rerender/10.avif)

### 2.6 `updateFunctionComponent()` による関数コンポーネントの再レンダーと children の reconcile

```javascript
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps: any,
  renderLanes
) {
  let context;
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let nextChildren;
  let hasId;
  prepareToReadContext(workInProgress, renderLanes);

  nextChildren = renderWithHooks(
    // ~ これは関数コンポーネントを実行し、子要素を返します
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  );

  hasId = checkDidRenderIdHook();
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  // React DevToolsはこのフラグを読み取ります
  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  // ~ nextChildrenを渡し、reconcileChildren()を呼び出します
  return workInProgress.child;
}
```

`reconcileChildren()`は[React が初期マウントを行う方法](/2023-07-14-initial-mount/)で内部的にいくつかのバリエーションがあり、children のタイプに応じて異なります。3 つに焦点を当てます。

新しい子 fiber を作成することに加えて、既存の fiber を再利用しようとします。

```javascript
function reconcileChildFibersImpl(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  ...
  // オブジェクトタイプの処理
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          //If just a single child
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
       ...
      case REACT_LAZY_TYPE:
        ...
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(
    // childrenが要素の配列の場合
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    ...
  }

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    return placeSingleChild(
      // childrenがテキストの場合
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // 残りのケースはすべて空として扱われます
  return deleteRemainingChildren(returnFiber, currentFirstChild);
  //-----------------------
}
```

`<Component/>`は単一の`div`を返します。したがって、`reconcileSingleElement()`に進みます。

### 2.7 `reconcileSingleElement()`

```javascript
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  // ~ これはComponent()の戻り値、`<div/>`の要素です
  lanes: Lanes,
): Fiber {
  const key = element.key;
  let child = currentFirstChild;
  while (child !== null) {
    // TODO: key === nullかつchild.key === nullの場合、リストの最初のアイテムにのみ適用
    if (child.key === key) {
      const elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) {
        ...
      } else {
        if (
          child.elementType === elementType ||
          // ~ タイプが同じ場合、再利用可能
          // ~ それ以外の場合はdeleteChild()を実行
          // このチェックはfalseパスでのみ実行されるようインライン化
          (__DEV__
            ? isCompatibleFamilyForHotReloading(child, element)
            : false) ||
          // Lazyタイプは解決後のタイプでreconcileする必要あり
          // ホットリロードチェックの後で実行する必要がある
          // ホットリロードは再サスペンドせず、prodとは異なるセマンティクスを持つため
          // 以下の呼び出しをサスペンドさせることはできない
          (typeof elementType === 'object' &&
            elementType !== null &&
            elementType.$$typeof === REACT_LAZY_TYPE &&
            resolveLazy(elementType) === child.type)
        ) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          // ~ 既存のfiberを新しいpropsで再利用する試み
          // ~ element.propsは`<div/>`のprops
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          return existing;
        }
      }
      // マッチしなかった場合
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  if (element.type === REACT_FRAGMENT_TYPE) {
    ...
  } else {
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, currentFirstChild, element);
    created.return = returnFiber;
    return created;
  }
}
```

`useFiber`内では、React は以前のバージョンを新規作成または再利用します。
前述の通り、子要素を含む`pendingProps`が設定されます。

```javascript
function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {
  // シングルチャイルドの場合のreturn忘れを防ぐため、siblingをnullにしindexを0に設定
  const clone = createWorkInProgress(fiber, pendingProps);
  //-----------------------------------------
  clone.index = 0;
  clone.sibling = null;
  return clone;
}
```

コンポーネントが再レンダーされた後、React は新しい`<div/>`である子要素に移動します。
この現在のバージョンは空の`lanes`と`childLanes`を持っています。

### 2.8 コンポーネントが再レンダーされると、そのサブツリーはデフォルトで再レンダーされる

`<div/>`とその children に scheduled work がない場合、bailout が発生すると考えがちですが、実際にはそうなりません。

`beginWork()`内で行われる`memoizedProps`と`pendingProps`のチェックを思い出してください。

```javascript
const oldProps = current.memoizedProps;
const newProps = workInProgress.pendingProps;

if (
  oldProps !== newProps ||
  //---------------------
  hasLegacyContextChanged() ||
  // ホットリロードによる実装変更時は強制再レンダー
  (__DEV__ ? workInProgress.type !== current.type : false)
) {
  // propsまたはcontextが変更された場合、workを実行済みとしてマーク
  // もしpropsが後から等しいと判明した場合、後で解除される可能性あり
  didReceiveUpdate = true;
}
```

ここで重要なのは、props の比較に shallow equal が使用されていない点です。
コンポーネントがレンダーされるたびに、React 要素を含む新しいオブジェクトが生成されるため、`pendingProps`は毎回新しく作成されます。

`<div/>`の場合、`Component()`が実行されると常に新しい props が取得されるため、bailout は発生しません。

したがって React は update ブランチ（`updateHostComponent()`）に進みます。

### 2.9 `updateHostComponent()`

```javascript


Props : null;

  let nextChildren = nextProps.children;
  const isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // ホストノードの直接のテキストなchildを特別扱いします。これは一般的なケースです。
    // 具象化された子として扱わず、代わりにこのpropにアクセスできるホスト環境で処理します。
    // これにより別のHostText fiberの割り当てと走査を回避できます。
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // 直接のテキストchildから通常の子、または空への切り替え時、
    // テキストコンテンツのリセットをスケジュールする必要があります
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  //---------------------------------------------------------------------
  return workInProgress.child;
}
```

`nextChildren` here is:

```javascript
[
  { $$typeof: Symbol(react.element), type: "button" },
  " (",
  { $$typeof: Symbol(react.element), type: "b" },
  ")",
];
```

React は内部的に`reconcileChildrenArray()`を使用してこれを調整します。

`current`の`memoizedProps`は次のようになります:

```javascript
[
  { $$typeof: Symbol(react.element), type: "button" },
  " (",
  { $$typeof: Symbol(react.element), type: "span" },
  ")",
];
```

### 2.10 `reconcileChildrenArray()` が必要に応じて fiber を作成・削除

`reconcileChildrenArray()`はやや複雑です。
要素の並び替えがあるかどうかをチェックし、`key`が存在する場合は fiber の再利用を試みる追加の最適化を行います。

`key`については、別途解説記事 [How does 'key' work internally? List diffing in React](/react/2022/02/08/the-diffing-algorithm-for-array-in-react/) を参照してください。

今回のデモでは`key`を使用していないため、基本のブランチ処理に進みます。

```javascript
function reconcileChildrenArray(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChildren: Array,
    lanes: Lanes,
  ): Fiber | null {
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;

    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      // 既存のfiberと新しい子要素を比較
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        // リスト内の各fiberを新しいpropsでチェック
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber === null) {
        // TODO: null子要素などの空スロットで中断される問題があります。
        // 常に低速パスをトリガーするため、残念です。
        // ミスかnull、undefined、falseのいずれかであると伝えるより良い方法が必要です。
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // fiberを再利用できない場合、Deletionとしてマーク
          // commitフェーズでDOMノードが削除される
          // スロットが一致したが、既存のfiberを再利用しなかった場合なので、既存のchildを削除
          deleteChild(returnFiber, oldFiber);
          //-----------
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      // ~ この処理はfiberをInsertionとしてマークしようとします
      if (previousNewFiber === null) {
        // TODO: ループの外に移動。これは最初の実行時のみ発生します
        resultingFirstChild = newFiber;
      } else {
        // TODO: このスロットの正しいインデックスにない場合、siblingの処理を遅延
        // 例えば以前にnull値があった場合、各null値に対してこれを遅延させたい
        // ただし、前の要素でupdateSlotを呼び出したくない場合もあります
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // 新しいchildrenの終端に到達。残りを削除できます
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    ...

    return resultingFirstChild;
  }
```

`updateSlot()`は基本的に、`key`を考慮しながら新しい props で fiber を作成または再利用します。

```javascript
function updateSlot(
  returnFiber: Fiber,
  oldFiber: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // keyが一致する場合のみfiberを更新、それ以外はnullを返す
  const key = oldFiber !== null ? oldFiber.key : null;

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    // テキストノードはkeyを持たない。前のノードが暗黙的にkey付けされていても、
    // テキストノードでなくても置換を継続可能
    if (key !== null) {
      return null;
    }
    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
  }

  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE: {
        if (newChild.key === key) {
          return updateElement(returnFiber, oldFiber, newChild, lanes);
        //-------------
        } else {
          return null;
        }
      }
      ...
    }
  }

  return null;
}

function updateElement(
  returnFiber: Fiber,
  current: Fiber | null,
  element: ReactElement,
  lanes: Lanes,
): Fiber {
  const elementType = element.type;
  if (elementType === REACT_FRAGMENT_TYPE) {
    return updateFragment(
      returnFiber,
      current,
      element.props.children,
      lanes,
      element.key,
    );
  }
  if (current !== null) {
    if (
      current.elementType === elementType ||
      // このチェックはfalseパスでのみ実行されるようインライン化
      (__DEV__
        ? isCompatibleFamilyForHotReloading(current, element)
        : false) ||
      // Lazyタイプは解決後のタイプでreconcileする必要あり
      // ホットリロードチェックの後で実行する必要がある
      // ホットリロードは再サスペンドせず、prodとは異なるセマンティクスを持つため
      // 以下の呼び出しをサスペンドさせることはできない
      (typeof elementType === 'object' &&
        elementType !== null &&
        elementType.$$typeof === REACT_LAZY_TYPE &&
        resolveLazy(elementType) === current.type)
    ) {
      // インデックスに基づいて移動
      const existing = useFiber(current, element.props);
      existing.ref = coerceRef(returnFiber, current, element);
      existing.return = returnFiber;
      return existing;
    }
  }
  // 挿入
  const created = createFiberFromElement(element, returnFiber.mode, lanes);
  created.ref = coerceRef(returnFiber, current, element);
  created.return = returnFiber;
  return created;
}
```

`<div/>`の場合、`updateSlot()`は 3 つの子要素の再利用に成功しましたが、3 番目の要素は
`current`が`span`であるのに対して必要な要素が`b`であったため、`b`の fiber が新規に作成され、
`span`の fiber は`deleteChild()`によって削除されます。新しく作成された`b`は`placeChild()`によってマークされます。

### 2.11 `placeChild()` and `deleteChild()` marks fiber with flags

Ok, for the children of `<div>` under `Component`, we have these 2 functions
that marks fiber nodes.

```javascript
function placeChild(
  newFiber: Fiber,
  lastPlacedIndex: number,
  newIndex: number
): number {
  newFiber.index = newIndex;
  if (!shouldTrackSideEffects) {
    // ハイドレーション中、useIdアルゴリズムはchildrenのリスト（配列やイテレータ）に属するfiberを認識する必要があります
    newFiber.flags |= Forked;
    return lastPlacedIndex;
  }
  const current = newFiber.alternate;
  if (current !== null) {
    const oldIndex = current.index;
    if (oldIndex < lastPlacedIndex) {
      // 移動操作としてマーク
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    } else {
      // アイテムは元の位置に留まることが可能
      return oldIndex;
    }
  } else {
    // 新規挿入としてマーク
    newFiber.flags |= Placement;
    return lastPlacedIndex;
  }
}
```

```javascript
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
  if (!shouldTrackSideEffects) {
    // 何もしない
    return;
  }
  const deletions = returnFiber.deletions;
  if (deletions === null) {
    returnFiber.deletions = [childToDelete];
    returnFiber.flags |= ChildDeletion;
  } else {
    deletions.push(childToDelete);
  }
}
```

削除対象の fiber は親の配列に一時的に格納されます。これは削除後新しい fiber ツリーに存在しなくなるため、
コミットフェーズで処理される必要があるからです。そのためどこかに保持しておく必要があります。

以上で`<div>`の処理は完了です。

![divの処理終了](https://jser.dev/static/rerender/13.avif)

次に React は`button`に移動します。スケジュールされた work がなくても、
props が`["click me-", "1"]`から`["click me-", "2"]`に変更されているため、
React は`updateHostComponent()`で処理を続行します。

HostText の場合、props は文字列であるため最初の`"click me -"`はベイルアウトします。
その後 React は`updateHostText()`でテキストの調整を試みます。

### 2.12 `updateHostText()`

```javascript
function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}
```

Again it doesn't nothing, because the updates are marked in complete phase - `completeWork()`.
This is also explained in [initial mount](/2023-07-14-initial-mount/#313-dom-nodes-are-created-offscreen-in-completework).

### 2.13 `completeWork()` による HostComponent の更新マーキングと DOM ノード作成

```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  // Note: This intentionally doesn't check if we're hydrating because comparing
  // to the current tree provider fiber is just as fast and less error-prone.
  // Ideally we would have a special version of the work loop only
  // for hydration.
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);
      return null;
    case HostComponent: {
      popHostContext(workInProgress);
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      if (current !== null && workInProgress.stateNode != null) {
        //This is update branch we are having
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          rootContainerInstance,
        );

        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
      //This is the initial mount branch we overed in [previous episode](/2023-07-14-initial-mount)
        ...
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case HostText: {
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
       //This is update branch we are having
        const oldText = current.memoizedProps;
        // If we have an alternate, that means this is an update and we need
        // to schedule a side-effect to do the updates.
        updateHostText(current, workInProgress, oldText, newText);
      } else {
      //This is the initial mount branch we overed in [previous episode](/2023-07-14-initial-mount)
        ...
        if (wasHydrated) {
          if (prepareToHydrateHostTextInstance(workInProgress)) {
            markUpdate(workInProgress);
          }
        } else {
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    ...
  }
}
```

```javascript
updateHostText = function (
  //Notice this is a different `updateHostText()` in complete phase
  current: Fiber,
  workInProgress: Fiber,
  oldText: string,
  newText: string
) {
  // If the text differs, mark it as an update. All the work in done in commitWork.
  if (oldText !== newText) {
    markUpdate(workInProgress);
    //--------
  }
};

updateHostComponent = function (
  current: Fiber,
  workInProgress: Fiber,
  type: Type,
  newProps: Props,
  rootContainerInstance: Container
) {
  // If we have an alternate, that means this is an update and we need to
  // schedule a side-effect to do the updates.
  const oldProps = current.memoizedProps;
  if (oldProps === newProps) {
    // In mutation mode, this is sufficient for a bailout because
    // we won't touch this node even if children changed.
    return;
  }

  // If we get updated because one of our children updated, we don't
  // have newProps so we'll have to reuse them.
  // TODO: Split the update API as separate for the props vs. children.
  // Even better would be if children weren't special cased at all tho.
  const instance: Instance = workInProgress.stateNode;
  const currentHostContext = getHostContext();
  // TODO: Experiencing an error where oldProps is null. Suggests a host
  // component is hitting the resume path. Figure out why. Possibly
  // related to `hidden`.
  const updatePayload: null | UpdatePayload = prepareUpdate(
    instance,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
    currentHostContext
  );
  // TODO: Type this specific to this type of component.
  workInProgress.updateQueue = (updatePayload: any);
  //----------
  //the update is put in updateQueue
  // ~ This actually is also used for hooks like [Effect Hooks](/2023-07-08-how-does-useeffect-work/)

  // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update. All the work is done in commitWork.
  if (updatePayload) {
    markUpdate(workInProgress);
    //----------
  }
};

function markUpdate(workInProgress: Fiber) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
  //---------------
  // ~ Yep, another flag!
}
```

So we are done with the Render phase and here we got

1.  an Insertion on `b`
2.  a Deletion on `span`
3.  an update on HostText
4.  an update on `button` (empty under the hood).

One thing I'd like to point out is that `prepareUpdate()` is run for both `button` and its parent `div`,
yet it generates `null` for `div` but `[]` for `button`. It is some tricky edge case handling
that we won't dive into here.

![Fiber Tree Render Phase End](https://jser.dev/static/rerender/25.avif)

It's time to commit these updates in Commit phase.

## 3. Re-render in Commit Phase

### 3.1 `commitMutationEffectsOnFiber()` による挿入/削除/更新の開始

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      //----------------------------------
      // ~ Recursively handles children First
      commitReconciliationEffects(finishedWork);
      //----------------------------------
      // ~ Then Insertion
      if (flags & Update) {
        //--------------------
        //Update at last
        try {
          commitHookEffectListUnmount(
            HookInsertion | HookHasEffect,
            finishedWork,
            finishedWork.return,
          );
          commitHookEffectListMount(
            HookInsertion | HookHasEffect,
            finishedWork,
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        ...
      }
      return;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      //----------------------------------
      // ~ Recursively handles children First
      commitReconciliationEffects(finishedWork);
      //----------------------------------
      // ~ Then Insertion

      if (supportsMutation) {
        // TODO: ContentReset gets cleared by the children during the commit
        // phase. This is a refactor hazard because it means we must read
        // flags the flags after `commitReconciliationEffects` has already run;
        // the order matters. We should refactor so that ContentReset does not
        // rely on mutating the flag during commit. Like by setting a flag
        // during the render phase instead.
        if (finishedWork.flags & ContentReset) {
          const instance: Instance = finishedWork.stateNode;
          try {
            resetTextContent(instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }

        if (flags & Update) {
          //--------------------
          //Update at last
          const instance: Instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            const newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            const oldProps =
              current !== null ? current.memoizedProps : newProps;
            const type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              try {
                commitUpdate(
                  //------------
                  instance,
                  updatePayload,
                  type,
                  oldProps,
                  newProps,
                  finishedWork,
                );
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error,
                );
              }
            }
          }
        }
      }
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        if (supportsMutation) {
          if (finishedWork.stateNode === null) {
            throw new Error(
              'This should have a text node initialized. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }

          const textInstance: TextInstance = finishedWork.stateNode;
          const newText: string = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          const oldText: string =
            current !== null ? current.memoizedProps : newText;

          try {
            commitTextUpdate(textInstance, oldText, newText);
              //----------------
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    ...
  }
}
```

We can see that it is a recursive process and let's take a closer look at each
type of mutation.

### 3.2 Deletion are processed first, before processing children and self.

```javascript
function recursivelyTraverseMutationEffects(
  root: FiberRoot,
  parentFiber: Fiber,
  lanes: Lanes
) {
  // Deletions effects can be scheduled on any fiber type. They need to happen
  // before the children effects hae fired.
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      try {
        commitDeletionEffects(root, parentFiber, childToDelete);
        //---------------------
      } catch (error) {
        captureCommitPhaseError(childToDelete, parentFiber, error);
      }
    }
  }

  const prevDebugFiber = getCurrentDebugFiberInDEV();
  if (parentFiber.subtreeFlags & MutationMask) {
    let child = parentFiber.child;
    while (child !== null) {
      setCurrentDebugFiberInDEV(child);
      commitMutationEffectsOnFiber(child, root, lanes);
      //----------------------------
      child = child.sibling;
    }
  }
  setCurrentDebugFiberInDEV(prevDebugFiber);
}
```

Deletions are processed first, even before processing children.

```javascript
function commitDeletionEffects(
  root: FiberRoot,
  returnFiber: Fiber,
  deletedFiber: Fiber
) {
  if (supportsMutation) {
    // We only have the top Fiber that was deleted but we need to recurse down its
    // children to find all the terminal nodes.

    // Recursively delete all host nodes from the parent, detach refs, clean
    // up mounted layout effects, and call componentWillUnmount.

    // We only need to remove the topmost host child in each branch. But then we
    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We
    // could split this into two separate traversals functions, where the second
    // one doesn't include any removeChild logic. This is maybe the same
    // function as "disappearLayoutEffects" (or whatever that turns into after
    // the layout phase is refactored to use recursion).

    // Before starting, find the nearest host parent on the stack so we know
    // which instance/container to remove the children from.
    // TODO: Instead of searching up the fiber return path on every deletion, we
    // can track the nearest host component on the JS stack as we traverse the
    // tree during the commit phase. This would make insertions faster, too.
    let parent = returnFiber;
    findParent: while (parent !== null) {
      //--------------------------------
      //Since parent node doesn't necessary means it has backing DOM
      //Here it searches for the closest Fiber Node that has backingDOM
      switch (parent.tag) {
        case HostComponent: {
          hostParent = parent.stateNode;
          hostParentIsContainer = false;
          break findParent;
        }
        case HostRoot: {
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = true;
          break findParent;
        }
        case HostPortal: {
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = true;
          break findParent;
        }
      }
      parent = parent.return;
    }
    if (hostParent === null) {
      throw new Error(
        "Expected to find a host parent. This error is likely caused by " +
          "a bug in React. Please file an issue."
      );
    }
    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
    //----------------------------
    hostParent = null;
    hostParentIsContainer = false;
  } else {
    // Detach refs and call componentWillUnmount() on the whole subtree.
    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
    //----------------------------
  }

  detachFiberMutation(deletedFiber);
}
```

### 3.3 Insertions are processed next

This is so that newly created nodes could be set up in a tree structure.

```javascript
function commitReconciliationEffects(finishedWork: Fiber) {
  // Placement effects (insertions, reorders) can be scheduled on any fiber
  // type. They needs to happen after the children effects have fired, but
  // before the effects on this fiber have fired.
  const flags = finishedWork.flags;
  if (flags & Placement) {
    try {
      commitPlacement(finishedWork);
      //---------------
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    // Clear the "placement" from effect tag so that we know that this is
    // inserted, before any life-cycles like componentDidMount gets called.
    // TODO: findDOMNode doesn't rely on this any more but isMounted does
    // and isMounted is deprecated anyway so we should be able to kill this.
    finishedWork.flags &= ~Placement;
  }
  if (flags & Hydrating) {
    finishedWork.flags &= ~Hydrating;
  }
}

function commitPlacement(finishedWork: Fiber): void {
  if (!supportsMutation) {
    return;
  }

  // Recursively insert all host nodes into the parent.
  const parentFiber = getHostParentFiber(finishedWork);

  // Note: these two variables *must* always be updated together.
  switch (parentFiber.tag) {
    case HostComponent: {
      const parent: Instance = parentFiber.stateNode;
      if (parentFiber.flags & ContentReset) {
        // Reset the text content of the parent before doing any insertions
        resetTextContent(parent);
        // Clear ContentReset from the effect tag
        parentFiber.flags &= ~ContentReset;
      }

      const before = getHostSibling(finishedWork);
      // ~ This is important. [Node.insertBefore()](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) needs the sibling node
      // ~ If we cannot find it, then we just append it to the end
      // We only have the top Fiber that was inserted but we need to recurse down its
      // children to find all the terminal nodes.
      insertOrAppendPlacementNode(finishedWork, before, parent);
      //---------------------------
      break;
    }
    case HostRoot:
    case HostPortal: {
      const parent: Container = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
      break;
    }
    // eslint-disable-next-line-no-fallthrough
    default:
      throw new Error(
        "Invalid host parent fiber. This error is likely caused by a bug " +
          "in React. Please file an issue."
      );
  }
}

function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode: Instance = node.stateNode;
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
  } else {
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(
  node: Fiber,
  before: ?Instance,
  parent: Instance
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode: Instance = node.stateNode;
    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
  } else {
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
```

### 3.4 Updates are handled at last

Update branch is inside `commitMutationEffectsOnFiber()`.

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        //For FunctionComponent, this means hooks need to be run
        try {
          commitHookEffectListUnmount(
            HookInsertion | HookHasEffect,
            finishedWork,
            finishedWork.return,
          );
          commitHookEffectListMount(
            HookInsertion | HookHasEffect,
            finishedWork,
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        if (
          enableProfilerTimer &&
          enableProfilerCommitHooks &&
          finishedWork.mode & ProfileMode
        ) {
          try {
            startLayoutEffectTimer();
            commitHookEffectListUnmount(
              HookLayout | HookHasEffect,
              finishedWork,
              finishedWork.return,
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          recordLayoutEffectDuration(finishedWork);
        } else {
          try {
            commitHookEffectListUnmount(
              HookLayout | HookHasEffect,
              finishedWork,
              finishedWork.return,
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Ref) {
        if (current !== null) {
          safelyDetachRef(current, current.return);
        }
      }
      if (supportsMutation) {
        // TODO: ContentReset gets cleared by the children during the commit
        // phase. This is a refactor hazard because it means we must read
        // flags the flags after `commitReconciliationEffects` has already run;
        // the order matters. We should refactor so that ContentReset does not
        // rely on mutating the flag during commit. Like by setting a flag
        // during the render phase instead.
        if (finishedWork.flags & ContentReset) {
          const instance: Instance = finishedWork.stateNode;
          try {
            resetTextContent(instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }

        if (flags & Update) {
          //For HostComponent, this means element attributes are needed to be updated
          const instance: Instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            const newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            const oldProps =
              current !== null ? current.memoizedProps : newProps;
            const type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              try {
                commitUpdate(
                  //------------
                  instance,
                  updatePayload,
                  type,
                  oldProps,
                  newProps,
                  finishedWork,
                );
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error,
                );
              }
            }
          }
        }
      }
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      if (flags & Update) {
        if (supportsMutation) {
          if (finishedWork.stateNode === null) {
            throw new Error(
              'This should have a text node initialized. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }

          const textInstance: TextInstance = finishedWork.stateNode;
          const newText: string = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          const oldText: string =
            current !== null ? current.memoizedProps : newText;

          try {
            commitTextUpdate(textInstance, oldText, newText);
              //----------------
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      return;
    }
    ...
  }
}
```

```javascript
export function commitUpdate(
  domElement: Instance,
  updatePayload: Array<mixed>,
  type: string,
  oldProps: Props,
  newProps: Props,
  internalInstanceHandle: Object
): void {
  // Apply the diff to the DOM node.
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
  //----------------
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps);
}

export function commitTextUpdate(
  textInstance: TextInstance,
  oldText: string,
  newText: string
): void {
  textInstance.nodeValue = newText;
}
```

So we are done with the Render phase and here we got

1.  an Insertion on `b`
2.  a Deletion on `span`
3.  an update on HostText
4.  an update on `button` (empty under the hood).

One thing I'd like to point out is that `prepareUpdate()` is run for both `button` and its parent `div`,
yet it generates `null` for `div` but `[]` for `button`. It is some tricky edge case handling
that we won't dive into here.

![End Result of Re-render](https://jser.dev/static/rerender/25.avif)

It's time to commit these updates in Commit phase.

## 4. Summary

Phew that is a lot. I'd roughly summarize the re-render process as below.

1.  After state changes, paths to target Fiber Node are marked with `lanes` and `childLanes`,
    to indicate if they or their subtree need to be re-rendered.
2.  React re-render the whole Fiber Tree, with optimization of bailout to avoid re-rendering
    unnecessarily.
3.  Once a component re-renders, it generates new React elements, its children all get
    new props even though they are equal, so React re-renders the whole Fiber Tree by default.
    Here is why you might need `useMemo()`.
4.  By "re-render", React creates a new Fiber Tree out of current one, also marks the Fiber
    Node with flags of `Placement` `ChildDeletion` and `Update` if needed.
5.  Once the new Fiber Tree is done, React processes Fiber Nodes with above flags and apply
    the changes to Host DOM in Commit phase.
6.  Then the new Fiber Tree is pointed to as the current Fiber Tree. The nodes on previous Fiber Tree
    could be reused for next render.

I've put the steps into slides below, hope it helps.

Want to know more about how React works internally?
Check out my series - **React Internals Deep Dive**!
