---
title: React の初期マウントは内部でどのように行われるのでしょうか？
---

# How does React do the initial mount internally?

:::info
Episode 2 from [React Internals Deep Dive](/series/react-source-code-walkthrough.html), watch me [explaining this on Youtube](https://www.youtube.com/watch?v=b7rrXJl5o5I&list=PLvx8w9g4qv_p-OS-XdbB3Ux_6DMXhAJC3&index=37)
:::

:::warning
Based on [React@18.2.0](https://github.com/facebook/react/releases/tag/v18.2.0), the implementation might have changed in newer version.
:::

In [Overview of React internals](/2023-07-11-overall-of-react-internals) we briefly
mentioned that React uses tree-like structure(Fiber Tree) internally to calculate the minimum DOM
updates and commit them in Commit phase. In this post, we’ll figure out how exactly
React does the initial mount (first-time render). To be more specific, we’d like to know
how React construct the DOM from code below.

![Fiber Tree](https://jser.dev/static/fiber-brief-intro-light.png)

## 1. Brief introduction on Fiber Architecture

Fiber is the architecture of how React holds internal representation of the App state.
It is a tree-like structure consisting FiberRootNode and FiberNodes. There are all
kinds of FiberNode and some of them have backing DOM node - HostComponent.

React runtime tries its best to maintain and update the Fiber Tree and sync the host
DOM with minimum updates.

### 1.1 FiberRootNode

FiberRootNode is a special node that acts as the React root, it holds the necessary meta
info about the whole app. Its `current` points to the actual Fiber Tree,
every time a new Fiber Tree is constructed, it re-points its `current` to the new `HostRoot`.

### 1.2 FiberNode

FiberNode means all nodes other than FiberRootNode, some of important properties are:

1. `tag`: FiberNode has many sub type differentiated by `tag`. For example,
   FunctionComponent, HostRoot, ContextConsumer,MemoComponent,SuspenseComponent .etc
2. `stateNode`: it points to other backing data, for `HostComponent`,
   `stateNode` points to the actual backing DOM node.
3. `child`, `sibling` and `return` : these together form a tree-like structure.
4. `elementType` which is the component function or intrinsic HTML tag we provide.
5. `flags`: to indicate the updates to apply in Commit phase. `subtreeFlags` is for its subtree.
6. `lanes`: to indicate the priority of pending updates. `childLanes` if for its subtree.
7. `memoizedState`: points to its important data, for FunctionComponent it means the hooks.

## 2. Initial mount in Trigger phase

`createRoot()` creates React root which also has a dummy HostRoot FiberNode created as `current`.

```javascript
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  let isStrictMode = false;
  let concurrentUpdatesByDefaultOverride = false;
  let identifierPrefix = '';
  let onRecoverableError = defaultOnRecoverableError;
  let transitionCallbacks = null;

  // ~ This returns FiberRootNode
  const root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );
  markContainerAsRoot(root.current, container);
  Dispatcher.current = ReactDOMClientDispatcher;

  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement);

  return new ReactDOMRoot(root);
}


export function createContainer(
  containerInfo: Container,
  tag: RootTag,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
  identifierPrefix: string,
  onRecoverableError: (error: mixed) => void,
  transitionCallbacks: null | TransitionTracingCallbacks,
): OpaqueRoot {
  const hydrate = false;
  const initialChildren = null;
  return createFiberRoot(
    containerInfo,
    tag,
    hydrate,
    initialChildren,
    hydrationCallbacks,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );
}

export function createFiberRoot(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  initialChildren: ReactNodeList,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
  identifierPrefix: string,
  onRecoverableError: null | ((error: mixed) => void),
  transitionCallbacks: null | TransitionTracingCallbacks,
): FiberRoot {
  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions
  const root: FiberRoot = (new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onRecoverableError,
  ): any);
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  const uninitializedFiber = createHostRootFiber(
    tag,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
  );
  // ~ A FiberNode of HostRoot is created and assigned as current of React root
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  ...
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

`root.render()` schedules update on HostRoot. The argument of element is stored in update payload.

```javascript
function ReactDOMRoot(internalRoot: FiberRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children: ReactNodeList): void {
    const root = this._internalRoot;
    if (root === null) {
      throw new Error("Cannot update an unmounted root.");
    }
    updateContainer(children, root, null, null);
  };
```

```javascript
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function
): Lane {
  const current = container.current;
  const lane = requestUpdateLane(current);

  if (enableSchedulingProfiler) {
    markRenderScheduled(lane);
  }

  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  const update = createUpdate(lane);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  // ~ The argument of render() is stored in the update payload
  update.payload = { element };
  // ~ Then the update is enqueued. We won't dive into how this is done
  // ~ Just remember that the update is waiting to be processed.
  const root = enqueueUpdate(current, update, lane);
  if (root !== null) {
    scheduleUpdateOnFiber(root, current, lane);
    entangleTransitions(root, current, lane);
  }

  return lane;
}
```

# 3. Initial mount in Render phase

### 3.1 `performConcurrentWorkOnRoot()`

As mentioned in [Overview of React internals](/2023-07-11-overall-of-react-internals),
`performConcurrentWorkOnRoot()` is the entry point to start rendering for both initial
mount and re-render.

One thing to keep in mind is that even it is named with `concurrent`, it internally
still falls back to `sync` mode when necessary. Initial mount is one of the cases because
the DefaultLane is blocking lane.

```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
  ...
  // Determine the next lanes to work on, using the fields stored
  // on the root.
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  ...

  // We disable time-slicing in some cases: if the work has been CPU-bound
  // for too long ("expired" work, to prevent starvation), or we're in
  // sync-updates-by-default mode.
  // TODO: We only check `didTimeout` defensively, to account for a Scheduler
  // bug we're still investigating. Once the bug in Scheduler is fixed,
  // we can remove this, since we track expiration ourselves.
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);
  ...
}
```

```javascript
// ~ Blocking means it is important, should not be interrupted.
export function includesBlockingLane(root: FiberRoot, lanes: Lanes) {
  const SyncDefaultLanes =
    InputContinuousHydrationLane |
    InputContinuousLane |
    DefaultHydrationLane |
    // ~ DefaultLane is blocking lane
    DefaultLane;
  return (lanes & SyncDefaultLanes) !== NoLanes;
}
```

:::note
Refer to [What are Lanes in React](/react/2022/03/26/lanes-in-react/) to know more about Lanes
:::

From above code we see that for initial mount, concurrent mode is actually not used.
This makes sense, for initial mount, we should try to pain the UI as soon as possible,
it doesn’t help to defer it.

### 3.2 `renderRootSync()`

`renderRootSync()` internally is just a while loop.

```javascript
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
        // If we bailout on this work, we'll move them back (like above).
        // It's important to move them now in case the work spawns more work at the same priority with different updaters.
        // That way we can keep the current update and future updates separate.
        movePendingFibersToMemoized(root, lanes);
      }
    }

    workInProgressTransitions = getTransitionsForLanes(root, lanes);
    prepareFreshStack(root, lanes);
  }
  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}

// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  // ~ This while loop means if workInprogress exists,
  // ~ it'll keep on `performUnitOfWork()` on it
  while (workInProgress !== null) {
    // ~ per its name, it works on one unit of Fiber Node
    performUnitOfWork(workInProgress);
  }
}
```

Here we need to explain what `workInProgress` means. In React code base prefixes of `current`
and `workInProgress` are everywhere. Since React use Fiber Tree to represent current state
internally, every time there is an update, React needs to construct a new tree and diff
against the old. **So `current` means the current version which is painted on the UI, `workInProgress`
means the version that is the being built and will be used as next `current`**.

### 3.3 `performUnitOfWork()`

This is where React works on single Fiber Node to see if there is anything to be done.

In order to understand this section more easily, I recommend you first check out my
episode - [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/).

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  const current = unitOfWork.alternate;

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    // ~ as mentioned, `workLoopSync()` is just a while loop
    // ~ that keeps running `completeUnitOfWork()` on workInProgress
    // ~ So assigning workInProgress here means setting next Fiber Node to work on
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

`beginWork()` is where the actual rendering happens.

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // ~ If current is not null, meaning this is not initial mount
  if (current !== null) {
    ...
  } else {
    // ~ otherwise it is initial mount, so of course there is no update
    didReceiveUpdate = false
    ...
  }


  // ~ It handles different types of elements differently
  switch (workInProgress.tag) {
    // ~ IndeterminateComponent means the Class component or Function component
    // ~ that hasn't been instantiated yet. Once it is rendered it is determined
    // ~ with a right tag. We'll come back to this soon
    case IndeterminateComponent: {
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    // ~ The custom function component we write
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    // ~ This is HostRoot under FiberRootNode
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    // ~ This is the intrinsic HTML tags, like p, div .etc
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    // ~ This HTML text node
    case HostText:
      return updateHostText(current, workInProgress);
    // ~ There are more types
    case SuspenseComponent:
      ...
  }
}
```

Now it’s time to go through the rendering steps.

### 3.4 `prepareFreshStack()`

In `renderRootSync()`, there is an important call of `prepareFreshStack()`.

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  ...
  workInProgressRoot = root;
  // ~ The current of root is the FiberNode of HostRoot
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  finishQueueingConcurrentUpdates();
  return rootWorkInProgress;
}
```

So every time a fresh rendering starts, a new `workInProgress` is created from the current HostRoot.
It works as the root of new Fiber Tree.

Thus for the branches inside `beginWork()`, we’ll first go to `HostRoot` and `updateHostRoot()` is
next step.

### 3.5 `updateHostRoot()`

```javascript
function updateHostRoot(
  current: null | Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  pushHostRootContext(workInProgress);

  const nextProps = workInProgress.pendingProps;
  const prevState = workInProgress.memoizedState;
  const prevChildren = prevState.element;

  cloneUpdateQueue(current, workInProgress);
  // ~ This call processes the update mentioned at the beginning of this post
  // ~ Just keep in mind that the update scheduled is processed
  // ~ and the payload is extracted, the element is assigned as memoizedState
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  const nextState: RootState = workInProgress.memoizedState;
  const root: FiberRoot = workInProgress.stateNode;
  pushRootTransition(workInProgress, root, renderLanes);

  if (enableTransitionTracing) {
    pushRootMarkerInstance(workInProgress);
  }

  // Caution: React DevTools currently depends on this property
  // being called "element".
  // ~ We're able to get the argument of ReactDOMRoot.render()!
  const nextChildren = nextState.element;
  if (supportsHydration && prevState.isDehydrated) {
    ...
  } else {
    // Root is not dehydrated. Either this is a client-only root, or it
    // already hydrated.
    resetHydrationState();
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    // ~ Here current and workInprogress both don't have child
    // ~ And nextChildren is <App/>
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  return workInProgress.child;
  // ~ After reconciling, new child is created for workInProgress
  // ~ Returning here means that workLoopSync() will handle it next
}
```

### 3.6 `reconcileChildren()`

This is a very import function in React internals. Per its name, roughly we can think of
`reconcile` as `diff`. It compares new children against old children, and sets the right
`child` on `workInProgress`.

```javascript
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  // ~ if there is no current, meaning this is initial mount
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes
    );
    // ~ if there is current, meaning this is re-render, so reconcile
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes
    );
  }
}
```

As mentioned above, FiberRootNode always has `current`, so we go to the 2nd branch - `reconcileChildFibers`.
But since this is the initial mount, its child `current.child` is null.

Also notice that we are setting `child` on `workInProgress`, since `workInProgress` is
being constructed and it doesn’t have `child` yet.

### 3.7 `reconcileChildFibers()` vs `mountChildFibers()`.

The goal of `reconcile` is to try to reuse stuff we already have, we can treat `mount`
as a special primitive version of `reconcile`, in which we always refresh everything.

In fact in the code these two are not that different, they are same closures but with
slight different flag `shouldTrackSideEffects`.

```javascript
export const reconcileChildFibers: ChildReconciler =
  createChildReconciler(true);
export const mountChildFibers: ChildReconciler = createChildReconciler(false);

function createChildReconciler(
    // ~ This flag controls if we need to track insertions .etc
  shouldTrackSideEffects: boolean,
): ChildReconciler {

  ...

  function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    lanes: Lanes,
  ): Fiber | null {
    // This indirection only exists so we can reset `thenableState` at the end.
    // It should get inlined by Closure.
    thenableIndexCounter = 0;
    const firstChildFiber = reconcileChildFibersImpl(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes,
    );
    thenableState = null;
    // Don't bother to reset `thenableIndexCounter` to 0 because it always gets
    // set at the beginning.
    // ~ The first child fiber after reconciling children will be returned
    // ~ and set as child of workInprogress
    return firstChildFiber;
  }

  return reconcileChildFibers;
}
```

Imagine if we have a full fiber tree to be constructed, all nodes should
be marked as “needed to insert” after reconciling, right? But it is
obviously not necessary, we only need to insert the root and that’s it!
So this `mountChildFibers` is actually a internal improvement to make things
more explicit.

```javascript
function reconcileChildFibersImpl(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // This function is not recursive.
  // If the top level item is an array, we treat it as a set of children,
  // not as a fragment. Nested arrays on the other hand will be treated as
  // fragment nodes. Recursion happens at the normal flow.

  // Handle top level unkeyed fragments as if they were arrays.
  // This leads to an ambiguity between <>{[...]}</> and <>...</>.
  // We treat the ambiguous cases above the same.
  // TODO: Let's use recursion like we do for Usable nodes?
  const isUnkeyedTopLevelFragment =
    typeof newChild === 'object' &&
    newChild !== null &&
    newChild.type === REACT_FRAGMENT_TYPE &&
    newChild.key === null;
  if (isUnkeyedTopLevelFragment) {
    newChild = newChild.props.children;
  }

  // Handle object types
  if (typeof newChild === 'object' && newChild !== null) {
    // ~ This $$typeof is the typeof React Element
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // ~ We've dive into these 2 functions next
        return placeSingleChild(
            // ~ if children is React Element, like <App/>
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
        return placeSingleChild(
          reconcileSinglePortal(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_LAZY_TYPE:
        const payload = newChild._payload;
        const init = newChild._init;
        // TODO: This function is supposed to be non-recursive.
        return reconcileChildFibers(
          returnFiber,
          currentFirstChild,
          init(payload),
          lanes,
        );
    }

    // ~ if children is array
    if (isArray(newChild)) {
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    if (typeof newChild.then === 'function') {
      const thenable: Thenable<any> = (newChild: any);
      return reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        unwrapThenable(thenable),
        lanes,
      );
    }

    if (
      newChild.$$typeof === REACT_CONTEXT_TYPE ||
      newChild.$$typeof === REACT_SERVER_CONTEXT_TYPE
    ) {
      ...
    }

    throwOnInvalidObjectType(returnFiber, newChild);
  }

  // ~ This handles the most primitive case - updating the Text Node
  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {

    return placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // Remaining cases are all treated as empty.
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

We see that there are two steps. `reconcileXXX()` to do the diffing,
and `placeSingleChild()` to mark that the fiber needs insertion in DOM.

### 3.8 `reconcileSingleElement()`

```javascript
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  lanes: Lanes
): Fiber {
  const key = element.key;
  let child = currentFirstChild;
  // ~ This handles update if there is already child
  // ~ But under initial mount, there isn't, so we'll ignore it for now
  while (child !== null) {
    // TODO: If key === null and child.key === null, then this only applies to
    // the first item in the list.
    if (child.key === key) {
      const elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) {
        if (child.tag === Fragment) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props.children);
          existing.return = returnFiber;
          return existing;
        }
      } else {
        if (
          child.elementType === elementType ||
          // Keep this check inline so it only runs on the false path:
          (__DEV__
            ? isCompatibleFamilyForHotReloading(child, element)
            : false) ||
          // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          (typeof elementType === "object" &&
            elementType !== null &&
            elementType.$$typeof === REACT_LAZY_TYPE &&
            resolveLazy(elementType) === child.type)
        ) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          if (__DEV__) {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        }
      }
      // Didn't match.
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  if (element.type === REACT_FRAGMENT_TYPE) {
    const created = createFiberFromFragment(
      element.props.children,
      returnFiber.mode,
      lanes,
      element.key
    );
    created.return = returnFiber;
    return created;
  } else {
    // ~ Since there is no previous version, we just create a new fiber from the element
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, currentFirstChild, element);
    created.return = returnFiber;
    return created;
  }
}
```

`reconcileSingleElement()` for initial mount is quite simple as we see.
Notice that the newly created Fiber Node will be `child` on `workInProgress`.

One thing to notice is that when Fiber Node is created from custom component,
its tag is `IndeterminateComponent`, not `FunctionComponent` yet.

```javascript
export function createFiberFromElement(
  element: ReactElement,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  let owner = null;
  const type = element.type;
  const key = element.key;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes,
  );
  return fiber;
}

export function createFiberFromTypeAndProps(
  type: any, // React$ElementType
  key: null | string,
  pendingProps: any,
  owner: null | Fiber,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  let fiberTag = IndeterminateComponent;
  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
  let resolvedType = type;
  ...

  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  return fiber;
}
```

### 3.9 `placeSingleChild()`

`reconcileSingleElement()` only does Fiber Node reconciliation, and `placeSingleChild()`
is where child Fiber Node is marked to do insertion on DOM.

```javascript
function placeSingleChild(newFiber: Fiber): Fiber {
  // This is simpler for the single child case. We only need to do a
  // placement for inserting new children.
  // ~ Yes, the flag is used here(well in some other places as well)
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    // ~ Placement means the DOM sub-tree needs to be inserted
    newFiber.flags |= Placement | PlacementDEV;
  }
  return newFiber;
}
```

Notice that this is done on `child,` meaning in initial mount, the child of `HostRoot` is
marked with `Placement`. In our demo code, it is `<App/>`.

### 3.10 `mountIndeterminateComponent()`

Next branch in `beginWork()` we’ll look at is `IndeterminateComponent`. Since `<App/>` is under
HostRoot, and as mentioned already that Custom components are initially marked as `IndeterminateComponent`,
we’ll come here when when first time `<App/>` is reconciled.

```javascript
function mountIndeterminateComponent(
  _current: null | Fiber,
  workInProgress: Fiber,
  Component: $FlowFixMe,
  renderLanes: Lanes,
) {
  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);

  const props = workInProgress.pendingProps;
  let context;
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(
      workInProgress,
      Component,
      false,
    );
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  let value;
  let hasId;

  // ~ This runs function components and return the children elements
  value = renderWithHooks(
    null,
    workInProgress,
    Component,
    props,
    context,
    renderLanes,
  );
  hasId = checkDidRenderIdHook();

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;

  if (
    // Run these checks in production only if the flag is off.
    // Eventually we'll delete this branch altogether.
    !disableModulePatternComponents &&
    typeof value === 'object' &&
    value !== null &&
    typeof value.render === 'function' &&
    value.$$typeof === undefined
  ) {
    // Proceed under the assumption that this is a class instance
    // ~ Once rendered, it is no long IndeterminateComponent
    workInProgress.tag = ClassComponent;

    ...
  } else {
    // Proceed under the assumption that this is a function component
    // ~ Once rendered, it is no long IndeterminateComponent
    workInProgress.tag = FunctionComponent;

    if (getIsHydrating() && hasId) {
      pushMaterializedTreeId(workInProgress);
    }

    // ~ since here current is null, so  mountChildFibers() will be used
    reconcileChildren(null, workInProgress, value, renderLanes);
    return workInProgress.child;
  }
}
```

As mentioned, when rendering `<App/>`, `mountChildFibers()` is used because
different from HostRoot which always has current, there is no previous version for `<App/>` and
`placeSingleChild()` ignores the insertion flags.

`App()` returns `<div>`, which later is handled by `HostComponent` branch
in `beginWork()`.

### 3.11 `updateHostComponent()`

```javascript
function updateHostComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  pushHostContext(workInProgress);

  if (current === null) {
    // ~ For hydration, refer to How basic hydration works internally in React
    tryToClaimNextHydratableInstance(workInProgress);
  }

  const type = workInProgress.type;
  // ~ pendingProps holds the children of <div/>, which is the <p/>
  const nextProps = workInProgress.pendingProps;
  const prevProps = current !== null ? current.memoizedProps : null;

  let nextChildren = nextProps.children;
  // ~ This is an improvement if its children are static text, as in <a/>
  const isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  ...

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

Above process repeats for `<p/>`, except that `nextChildren` now is an array,
so `reconcileChildrenArray()` kicks in inside `reconcileChildFibers()`.

`reconcileChildrenArray()` is a bit more complex because of the existence of `key`,
for more details go to my another blog post -
[How does ‘key’ work internally? List diffing in React](/react/2022/02/08/the-diffing-algorithm-for-array-in-react/).

Other than the `key` handling, it basically return the first child fiber and continues,
the siblings will be processed later since React flattens the tree structure into linked list.
For more, please refer to [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/).

For `<Link/>`, we are repeating the process as `<App/>`.

For `<a>` and `<button>` we’ll go to deeper to its text.

But they are a bit different, `<a>` has a static text as children, while `<button>` has some JSX expression `{count}`.
That’s why in above code, `<a>` has `nextChildren` as null, but `<button>` continues to children.

### 3.12 `updateHostText()`

For `<button>` its children is an array - `["click me - ", "0"]`, `updateHostText()` is the branch
for both of them in `beginWork()`.

```javascript
function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.

  return null;
}
```

But it does nothing except handling hydration. How the text in `<a>` and `<button>` are handled
is in the Commit phase.

### 3.13 DOM nodes are created offscreen in `completeWork()`.

As mentioned in [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/),
`completeWork()` is called on a fiber before its sibling is tried with `beginWork()`.

Fiber Node has one important property - `stateNode`, which for intrinsic HTML tags, it refers
to the actual DOM node. And the actual creation of DOM node is done in `completeWork()`.

```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  // Note: This intentionally doesn't check if we're hydrating because comparing
  // to the current tree provider fiber is just as fast and less error-prone.
  // Ideally we would have a special version of the work loop only
  // for hydration.
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);
      return null;
    case ClassComponent: {
      const Component = workInProgress.type;
      if (isLegacyContextProvider(Component)) {
        popLegacyContext(workInProgress);
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case HostRoot: {
      ...
      return null;
    }
    ...
    // ~ For HTMl tags
    case HostComponent: {
      popHostContext(workInProgress);
      const type = workInProgress.type;
      // ~ If there is current version, then we go to update branch
      if (current !== null && workInProgress.stateNode != null) {
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          renderLanes,
        );

        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      // ~ But we don't have current version yet, so we go to this mount branch
      } else {
        ...
        if (wasHydrated) {
          ...
        } else {
          const rootContainerInstance = getRootHostContainer();

          // ~ The actual DOM node
          const instance = createInstance(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
          // ~ This is important, when an DOM node is created
          // ~ It needs to be the parent of all direct connected DOM nodes of subtree
          appendAllChildren(instance, workInProgress, false, false);
          workInProgress.stateNode = instance;

         if (
            // ~ This will be covered soon!
            finalizeInitialChildren(
              instance,
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            markUpdate(workInProgress);
          }
        }

        if (workInProgress.ref !== null) {
          // If there is a ref on a host node we need to schedule a callback
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);

      ...
      return null;
    }
    case HostText: {
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
        const oldText = current.memoizedProps;
        // If we have an alternate, that means this is an update and we need
        // to schedule a side-effect to do the updates.
        updateHostText(current, workInProgress, oldText, newText);
      } else {
        ...
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          if (prepareToHydrateHostTextInstance(workInProgress)) {
            markUpdate(workInProgress);
          }
        } else {
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    ...
  }
}
```

## 4. Initial mount in Commit phase

By now:

1. the workInProgress version of Fiber Tree is finally constructed!
2. the backing DOM nodes are also created and organized!
3. flags are set on necessary fibers to help guide the DOM manipulation!

Now it’s time to actually see how React manipulates the DOM.

### 4.1 `commitMutationEffects()`

Recall in [Overview of React internals](/2023-07-11-overall-of-react-internals)
we briefly explained Commit phase, we’ll go deeper in `commitMutationEffects()`
which handles the DOM mutation.

```javascript
export function commitMutationEffects(
  root: FiberRoot,
  // ~ The Fiber Node of HostRoot, holding the newly built Fiber Tree
  finishedWork: Fiber,
  committedLanes: Lanes
) {
  inProgressLanes = committedLanes;
  inProgressRoot = root;

  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);
  inProgressLanes = null;
  inProgressRoot = null;
}
```

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      // ~ This recursive call makes sure subtree is handled first
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      // ~ ReconciliationEffects means Insertion .etc.
      commitReconciliationEffects(finishedWork);

      ...

      return;
    }
    ...
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);
      ...
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      ...
      return;
    }
    case HostRoot: {
      if (enableFloat && supportsResources) {
        prepareToCommitHoistables();

        const previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root.containerInfo);

        recursivelyTraverseMutationEffects(root, finishedWork, lanes);
        currentHoistableRoot = previousHoistableRoot;

        commitReconciliationEffects(finishedWork);
      } else {
        recursivelyTraverseMutationEffects(root, finishedWork, lanes);
        commitReconciliationEffects(finishedWork);
      }

      ...
      return;
    }
    ...
    default: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      return;
    }
  }
}
```

```javascript
function recursivelyTraverseMutationEffects(
  root: FiberRoot,
  parentFiber: Fiber,
  lanes: Lanes
) {
  // Deletions effects can be scheduled on any fiber type. They need to happen
  // before the children effects hae fired.

  // ~ Deletion are handled differently
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      try {
        commitDeletionEffects(root, parentFiber, childToDelete);
      } catch (error) {
        captureCommitPhaseError(childToDelete, parentFiber, error);
      }
    }
  }

  const prevDebugFiber = getCurrentDebugFiberInDEV();
  if (parentFiber.subtreeFlags & MutationMask) {
    let child = parentFiber.child;
    while (child !== null) {
      setCurrentDebugFiberInDEV(child);
      commitMutationEffectsOnFiber(child, root, lanes);
      child = child.sibling;
    }
  }
  setCurrentDebugFiberInDEV(prevDebugFiber);
}
```

### 4.2 `commitReconciliationEffects`

`commitReconciliationEffects()` handles the Insertion, reordering .etc.

```javascript
function commitReconciliationEffects(finishedWork: Fiber) {
  // Placement effects (insertions, reorders) can be scheduled on any fiber
  // type. They needs to happen after the children effects have fired, but
  // before the effects on this fiber have fired.
  const flags = finishedWork.flags;
  // ~ Yep, the flag are checked here!
  if (flags & Placement) {
    try {
      commitPlacement(finishedWork);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    // Clear the "placement" from effect tag so that we know that this is
    // inserted, before any life-cycles like componentDidMount gets called.
    // TODO: findDOMNode doesn't rely on this any more but isMounted does
    // and isMounted is deprecated anyway so we should be able to kill this.
    finishedWork.flags &= ~Placement;
  }
  ...
}
```

So in our demo , Fiber Node of `<App/>` actually gets committed.

### 4.3 `commitPlacement()`

```javascript
function commitPlacement(finishedWork: Fiber): void {
  ...
  // Recursively insert all host nodes into the parent.
  const parentFiber = getHostParentFiber(finishedWork);
  // ~ Notice here we are checking parent fiber's type
  // ~ Because Insertion is done against parent node
  switch (parentFiber.tag) {
    case HostSingleton: {
      if (enableHostSingletons && supportsSingletons) {
        const parent: Instance = parentFiber.stateNode;
        const before = getHostSibling(finishedWork);
        // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        insertOrAppendPlacementNode(finishedWork, before, parent);
        break;
      }
      // Fall through
    }
    // ~ We won't touch this branch in initial mount
    case HostComponent: {
      const parent: Instance = parentFiber.stateNode;
      if (parentFiber.flags & ContentReset) {
        // Reset the text content of the parent before doing any insertions
        resetTextContent(parent);
        // Clear ContentReset from the effect tag
        parentFiber.flags &= ~ContentReset;
      }

      const before = getHostSibling(finishedWork);
      // We only have the top Fiber that was inserted but we need to recurse down its
      // children to find all the terminal nodes.
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    // ~ The Fiber Node that has Placement flag for initial mount is <App/>
    // ~ its parentFiber is HostRoot
    case HostRoot:
    case HostPortal: {
        // ~ the stateNode of HostRoot points to FiberRootNode
      const parent: Container = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
      break;
    }
    default:
      throw new Error(
        'Invalid host parent fiber. This error is likely caused by a bug ' +
          'in React. Please file an issue.',
      );
  }
}
```

The idea is to insert or append the DOM of `finishedWork` into parent container, at the right position.

```javascript
function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode = node.stateNode;
    // ~ if it is DOM elements, just insert it
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (
    tag === HostPortal ||
    (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)
  ) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
    // If the insertion is a HostSingleton then it will be placed independently
  } else {
    // ~ For non-DOM elements, recursively handle their children
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
```

And this is how the DOM is finally inserted.

## 5. Summary

Alright, we finally see how the DOM is created and inserted to the container.
So for initial mount,

1. Fiber Tree is lazily created during reconciliation, the backing DOM nodes are created and organized at the same time.
2. The direct child of `HostRoot` is marked as `Placement`.
3. In commit phase, we just find fiber with `Placement`. Since its parent is HostRoot, its DOM node is inserted into container.
