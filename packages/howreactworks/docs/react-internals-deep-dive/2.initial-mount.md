---
title: React の初期マウントは内部でどのように行われるのでしょうか？
---

# React の初期マウントは内部でどのように行われるのでしょうか？

:::info
[React Internals Deep Dive](/series/react-source-code-walkthrough.html) のエピソード 2 です。解説動画は[YouTube で視聴可能](https://www.youtube.com/watch?v=b7rrXJl5o5I&list=PLvx8w9g4qv_p-OS-XdbB3Ux_6DMXhAJC3&index=37)
:::

:::warning
[React@18.2.0](https://github.com/facebook/react/releases/tag/v18.2.0) に基づいています。新しいバージョンでは実装が変更されている可能性があります
:::

[React の内部構造概要](/2023-07-11-overall-of-react-internals)で簡単に触れたように、React は内部で Fiber Tree と呼ばれるツリー構造を使用して最小限の DOM 更新を計算し、コミットフェーズで確定します。この記事では、React が初期マウント（初回レンダリング）をどのように行うのかを詳細に解説します。具体的には、以下のコードから DOM がどのように構築されるのかを追っていきます。

## 1. Fiber アーキテクチャの概要

Fiber は React の内部状態の表現方法です。これは FiberRootNode と FiberNodes で構成されるツリー構造です。FiberNode にはさまざまな種類があり、一部にはバッキング DOM ノードを持つものがあります(HostComponent)。

React ランタイムは Fiber Tree を維持し、更新し、最小限の更新でホスト DOM を同期します。
![Fiber Tree](https://jser.dev/static/fiber-brief-intro-light.png)

### 1.1 FiberRootNode

FiberRootNode は React のルートです。これはアプリ全体に関する必要なメタ情報を保持します。その`current`は実際の Fiber Tree を指し、新しい Fiber Tree が構築されるたびにその`current`を新しい`HostRoot`に再ポイントします。

### 1.2 FiberNode

FiberNode は FiberRootNode 以外のすべてのノードを意味します。重要なプロパティのいくつかは次のとおりです。

1. `tag`: FiberNode には多くのサブタイプがあり、`tag`によって区別されます。たとえば、FunctionComponent、HostRoot、ContextConsumer、MemoComponent、SuspenseComponent など。
2. `stateNode`: 他のバッキングデータを指すために使用されます。`HostComponent`の場合、`stateNode`は実際のバッキング DOM ノードを指します。
3. `child`、`sibling`、`return` : これらは一緒にツリー構造を形成します。
4. `elementType` は、提供されたコンポーネント関数または組み込み HTML タグです。
5. `flags`: Commit フェーズで適用する更新を示すために使用されます。`subtreeFlags`はそのサブツリー用です。
6. `lanes`: 保留中の更新の優先度を示すために使用されます。`childLanes`はそのサブツリー用です。
7. `memoizedState`: 重要なデータを指すために使用されます。FunctionComponent の場合、これはフックを意味します。

## 2. Trigger phase での初期マウント

`createRoot()`は React ルートを作成し、`current`としてダミーの HostRoot FiberNode を作成します。

```javascript
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  let isStrictMode = false;
  let concurrentUpdatesByDefaultOverride = false;
  let identifierPrefix = '';
  let onRecoverableError = defaultOnRecoverableError;
  let transitionCallbacks = null;

  // ~ ここでFiberRootNodeが返されます
  const root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );
  markContainerAsRoot(root.current, container);
  Dispatcher.current = ReactDOMClientDispatcher;

  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement);

  return new ReactDOMRoot(root);
}


export function createContainer(
  containerInfo: Container,
  tag: RootTag,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
  identifierPrefix: string,
  onRecoverableError: (error: mixed) => void,
  transitionCallbacks: null | TransitionTracingCallbacks,
): OpaqueRoot {
  const hydrate = false;
  const initialChildren = null;
  return createFiberRoot(
    containerInfo,
    tag,
    hydrate,
    initialChildren,
    hydrationCallbacks,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );
}

export function createFiberRoot(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  initialChildren: ReactNodeList,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
  identifierPrefix: string,
  onRecoverableError: null | ((error: mixed) => void),
  transitionCallbacks: null | TransitionTracingCallbacks,
): FiberRoot {
  // $FlowFixMe[invalid-constructor] Flowは関数のnew呼び出しをサポートしなくなりました
  const root: FiberRoot = (new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onRecoverableError,
  ): any);
  // 循環構造。stateNodeがanyのため、現在の型システムを回避しています
  const uninitializedFiber = createHostRootFiber(
    tag,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
  );
  // ~ HostRootのFiberNodeが作成され、React rootのcurrentとして割り当てられます
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  ...
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

`root.render()`は HostRoot に更新をスケジュールします。要素の引数は更新ペイロードに保存されます。

```javascript
function ReactDOMRoot(internalRoot: FiberRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children: ReactNodeList): void {
    const root = this._internalRoot;
    if (root === null) {
      throw new Error("Cannot update an unmounted root.");
    }
    updateContainer(children, root, null, null);
  };
```

```javascript
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function
): Lane {
  const current = container.current;
  const lane = requestUpdateLane(current);

  if (enableSchedulingProfiler) {
    markRenderScheduled(lane);
  }

  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  const update = createUpdate(lane);
  // 注意: React DevTools は現在、"element" と呼ばれるこのプロパティに依存しています
  // ~ render() の引数は update の payload に保存されます
  update.payload = { element };
  // ~ update は enqueue されます。この処理の詳細には立ち入りませんが
  // ~ update が処理待ち状態になることを覚えておいてください
  const root = enqueueUpdate(current, update, lane);
  if (root !== null) {
    scheduleUpdateOnFiber(root, current, lane);
    entangleTransitions(root, current, lane);
  }

  return lane;
}
```

# 3. Render phase での初期マウント

### 3.1 `performConcurrentWorkOnRoot()`

[React の内部構造概要](/2023-07-11-overall-of-react-internals)で触れたように、`performConcurrentWorkOnRoot()`は初期レンダリングと再レンダリングの両方のためにレンダリングを開始するエントリーポイントです。

1 つ注意すべき点は、それが`concurrent`と呼ばれているにもかかわらず、必要に応じて内部で`sync`モードにフォールバックすることです。初期マウントはそのようなケースの 1 つです。なぜなら、DefaultLane はブロッキングランをブロッキングするためです。

```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
  ...
  // ルートに保存されているフィールドを使用して、次に作業するレーンを決定します。
  let lanes = getNextLanes(
    root,
    root === workInProgres? workInProgressRootRenderLanes : NoLanes,
  );
  ...

  // 以下のケースではtime-slicingを無効化します:
  // 長時間CPUバウンドな処理（"expired" workによる starvation 防止）
  // またはsync-updates-by-defaultモードの場合
  // TODO: Schedulerのバグ対応として防御的に`didTimeout`をチェックしています
  // Schedulerのバグが修正され次第、このチェックは不要になります（自前でexpirationを追跡しているため）
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);
  ...
}
```

```javascript
// ~ Blockingは重要で、中断されるべきではない処理のことです
export function includesBlockingLane(root: FiberRoot, lanes: Lanes) {
  const SyncDefaultLanes =
    InputContinuousHydrationLane |
    InputContinuousLane |
    DefaultHydrationLane |
    // ~ DefaultLaneはblocking lane
    DefaultLane;
  return (lanes & SyncDefaultLanes) !== NoLanes;
}
```

:::note
[What are Lanes in React](/react/2022/03/26/lanes-in-react/)を参照してください。
:::

上記のコードから、初期マウントの場合、concurrent モードは実際には使用されないことがわかります。これは理にかなっています。初期マウントの場合、UI をできるだけ早く描画することが助けになるため、それを延期するのは助けになりません。

### 3.2 `renderRootSync()`

`renderRootSync()`は内部で単なる while ループです。

```javascript
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  // rootまたはlanesが変更された場合、既存のスタックを破棄して新規作成
  // 変更ない場合は前回の続きから処理を再開
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        // 今後のworkをスケジュールしたFibersをMapからSetに移動
        // bailout発生時は元に戻します（上記同様）
        // 異なるupdaterで同一優先度の追加workが生成される場合に備え、現在のupdateと
        // 将来のupdateを分離するため、この時点で移動することが重要
        movePendingFibersToMemoized(root, lanes);
      }
    }

    workInProgressTransitions = getTransitionsForLanes(root, lanes);
    prepareFreshStack(root, lanes);
  }
  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  // 進行中のレンダーがないことを示すためnullを設定
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}

// work loopは極めてホットなパスのためClosureのインライン化を抑制
/** @noinline */
function workLoopSync() {
  // タイムアウト済みのためyieldチェックせずにworkを実行
  // ~ このwhileループはworkInProgressが存在する限り
  // ~ `performUnitOfWork()`を継続的に実行することを意味します
  while (workInProgress !== null) {
    // ~ 名前の通り、1つのFiber Node単位で処理を実行
    performUnitOfWork(workInProgress);
  }
}
```

ここで`workInProgress`の意味を説明する必要があります。
React のコードベースでは`current`と`workInProgress`の接頭辞が至る所で見られます。React が内部状態を表現するために Fiber Tree を使用しているため、更新がある度に新しいツリーを構築し古いツリーとの diff を取る必要があります。**つまり、`current`は UI に描画されている現在のバージョンを指し、`workInProgress`は構築中の次期`current`として使用されるバージョンを意味します**。

### 3.3 `performUnitOfWork()`

これは React が単一の Fiber Node を見て、何かが行われるかどうかを確認する場所です。

このセクションをより簡単に理解するために、最初のエピソードを確認することをお勧めします - [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/).

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  const current = unitOfWork.alternate;

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    // ~ as mentioned, `workLoopSync()` is just a while loop
    // ~ that keeps running `completeUnitOfWork()` on workInProgress
    // ~ So assigning workInProgress here means setting next Fiber Node to work on
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

`beginWork()`は実際のレンダリングが行われる場所です。

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // ~ If current is not null, meaning this is not initial mount
  if (current !== null) {
    ...
  } else {
    // ~ otherwise it is initial mount, so of course there is no update
    didReceiveUpdate = false
    ...
  }


  // ~ It handles different types of elements differently
  switch (workInProgress.tag) {
    // ~ IndeterminateComponent means the Class component or Function component
    // ~ that hasn't been instantiated yet. Once it is rendered it is determined
    // ~ with a right tag. We'll come back to this soon
    case IndeterminateComponent: {
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    // ~ The custom function component we write
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    // ~ This is HostRoot under FiberRootNode
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    // ~ This is the intrinsic HTML tags, like p, div .etc
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    // ~ This HTML text node
    case HostText:
      return updateHostText(current, workInProgress);
    // ~ There are more types
    case SuspenseComponent:
      ...
  }
}
```

Now it's time to go through the rendering steps.

### 3.4 `prepareFreshStack()`

`renderRootSync()`には重要な`prepareFreshStack()`の呼び出しがあります。

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  ...
  workInProgressRoot = root;
  // ~ The current of root is the FiberNode of HostRoot
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  finishQueueingConcurrentUpdates();
  return rootWorkInProgress;
}
```

So every time a fresh rendering starts, a new `workInProgress` is created from the current HostRoot.
It works as the root of new Fiber Tree.

Thus for the branches inside `beginWork()`, we'll first go to `HostRoot` and `updateHostRoot()` is
next step.

### 3.5 `updateHostRoot()`

```javascript
function updateHostRoot(
  current: null | Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  pushHostRootContext(workInProgress);

  const nextProps = workInProgress.pendingProps;
  const prevState = workInProgress.memoizedState;
  const prevChildren = prevState.element;

  cloneUpdateQueue(current, workInProgress);
  // ~ This call processes the update mentioned at the beginning of this post
  // ~ Just keep in mind that the update scheduled is processed
  // ~ and the payload is extracted, the element is assigned as memoizedState
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  const nextState: RootState = workInProgress.memoizedState;
  const root: FiberRoot = workInProgress.stateNode;
  pushRootTransition(workInProgress, root, renderLanes);

  if (enableTransitionTracing) {
    pushRootMarkerInstance(workInProgress);
  }

  // Caution: React DevTools currently depends on this property
  // being called "element".
  // ~ We're able to get the argument of ReactDOMRoot.render()!
  const nextChildren = nextState.element;
  if (supportsHydration && prevState.isDehydrated) {
    ...
  } else {
    // Root is not dehydrated. Either this is a client-only root, or it
    // already hydrated.
    resetHydrationState();
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    // ~ Here current and workInprogress both don't have child
    // ~ And nextChildren is <App/>
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  return workInProgress.child;
  // ~ After reconciling, new child is created for workInProgress
  // ~ Returning here means that workLoopSync() will handle it next
}
```

### 3.6 `reconcileChildren()`

これは React の内部で非常に重要な関数です。その名前から、`reconcile`を`diff`として扱うことができます。これは新しい子供たちを古い子供たちと比較し、`workInProgress`の正しい`child`を設定します。

```javascript
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  // ~ if there is no current, meaning this is initial mount
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes
    );
    // ~ if there is current, meaning this is re-render, so reconcile
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes
    );
  }
}
```

As mentioned above, FiberRootNode always has `current`, so we go to the 2nd branch - `reconcileChildFibers`.
But since this is the initial mount, its child `current.child` is null.

Also notice that we are setting `child` on `workInProgress`, since `workInProgress` is
being constructed and it doesn't have `child` yet.

### 3.7 `reconcileChildFibers()` vs `mountChildFibers()`.

The goal of `reconcile` is to try to reuse stuff we already have, we can treat `mount`
as a special primitive version of `reconcile`, in which we always refresh everything.

In fact in the code these two are not that different, they are same closures but with
slight different flag `shouldTrackSideEffects`.

```javascript
export const reconcileChildFibers: ChildReconciler =
  createChildReconciler(true);
export const mountChildFibers: ChildReconciler = createChildReconciler(false);

function createChildReconciler(
    // ~ This flag controls if we need to track insertions .etc
  shouldTrackSideEffects: boolean,
): ChildReconciler {

  ...

  function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    lanes: Lanes,
  ): Fiber | null {
    // This indirection only exists so we can reset `thenableState` at the end.
    // It should get inlined by Closure.
    thenableIndexCounter = 0;
    const firstChildFiber = reconcileChildFibersImpl(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes,
    );
    thenableState = null;
    // Don't bother to reset `thenableIndexCounter` to 0 because it always gets
    // set at the beginning.
    // ~ The first child fiber after reconciling children will be returned
    // ~ and set as child of workInprogress
    return firstChildFiber;
  }

  return reconcileChildFibers;
}
```

Imagine if we have a full fiber tree to be constructed, all nodes should
be marked as "needed to insert" after reconciling, right? But it is
obviously not necessary, we only need to insert the root and that's it!
So this `mountChildFibers` is actually a internal improvement to make things
more explicit.

```javascript
function reconcileChildFibersImpl(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // This function is not recursive.
  // If the top level item is an array, we treat it as a set of children,
  // not as a fragment. Nested arrays on the other hand will be treated as
  // fragment nodes. Recursion happens at the normal flow.

  // Handle top level unkeyed fragments as if they were arrays.
  // This leads to an ambiguity between <>{[...]}</> and <>...</>.
  // We treat the ambiguous cases above the same.
  // TODO: Let's use recursion like we do for Usable nodes?
  const isUnkeyedTopLevelFragment =
    typeof newChild === 'object' &&
    newChild !== null &&
    newChild.type === REACT_FRAGMENT_TYPE &&
    newChild.key === null;
  if (isUnkeyedTopLevelFragment) {
    newChild = newChild.props.children;
  }

  // Handle object types
  if (typeof newChild === 'object' && newChild !== null) {
    // ~ This $$typeof is the typeof React Element
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // ~ We've dive into these 2 functions next
        return placeSingleChild(
            // ~ if children is React Element, like <App/>
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
        return placeSingleChild(
          reconcileSinglePortal(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_LAZY_TYPE:
        const payload = newChild._payload;
        const init = newChild._init;
        // TODO: This function is supposed to be non-recursive.
        return reconcileChildFibers(
          returnFiber,
          currentFirstChild,
          init(payload),
          lanes,
        );
    }

    // ~ if children is array
    if (isArray(newChild)) {
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    if (typeof newChild.then === 'function') {
      const thenable: Thenable<any> = (newChild: any);
      return reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        unwrapThenable(thenable),
        lanes,
      );
    }

    if (
      newChild.$$typeof === REACT_CONTEXT_TYPE ||
      newChild.$$typeof === REACT_SERVER_CONTEXT_TYPE
    ) {
      ...
    }

    throwOnInvalidObjectType(returnFiber, newChild);
  }

  // ~ This handles the most primitive case - updating the Text Node
  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {

    return placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // Remaining cases are all treated as empty.
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

We see that there are two steps. `reconcileXXX()` to do the diffing,
and `placeSingleChild()` to mark that the fiber needs insertion in DOM.

### 3.8 `reconcileSingleElement()`

```javascript
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  lanes: Lanes
): Fiber {
  const key = element.key;
  let child = currentFirstChild;
  // ~ This handles update if there is already child
  // ~ But under initial mount, there isn't, so we'll ignore it for now
  while (child !== null) {
    // TODO: If key === null and child.key === null, then this only applies to
    // the first item in the list.
    if (child.key === key) {
      const elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) {
        if (child.tag === Fragment) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props.children);
          existing.return = returnFiber;
          return existing;
        }
      } else {
        if (
          child.elementType === elementType ||
          // Keep this check inline so it only runs on the false path:
          (__DEV__
            ? isCompatibleFamilyForHotReloading(child, element)
            : false) ||
          // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          (typeof elementType === "object" &&
            elementType !== null &&
            elementType.$$typeof === REACT_LAZY_TYPE &&
            resolveLazy(elementType) === child.type)
        ) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, element.props);
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          if (__DEV__) {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        }
      }
      // Didn't match.
      deleteRemainingChildren(returnFiber, child);
      break;
    } else {
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }

  if (element.type === REACT_FRAGMENT_TYPE) {
    const created = createFiberFromFragment(
      element.props.children,
      returnFiber.mode,
      lanes,
      element.key
    );
    created.return = returnFiber;
    return created;
  } else {
    // ~ Since there is no previous version, we just create a new fiber from the element
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, currentFirstChild, element);
    created.return = returnFiber;
    return created;
  }
}
```

`reconcileSingleElement()` for initial mount is quite simple as we see.
Notice that the newly created Fiber Node will be `child` on `workInProgress`.

One thing to notice is that when Fiber Node is created from custom component,
its tag is `IndeterminateComponent`, not `FunctionComponent` yet.

```javascript
export function createFiberFromElement(
  element: ReactElement,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  let owner = null;
  const type = element.type;
  const key = element.key;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes,
  );
  return fiber;
}

export function createFiberFromTypeAndProps(
  type: any, // React$ElementType
  key: null | string,
  pendingProps: any,
  owner: null | Fiber,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  let fiberTag = IndeterminateComponent;
  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
  let resolvedType = type;
  ...

  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  return fiber;
}
```

### 3.9 `placeSingleChild()`

`reconcileSingleElement()` only does Fiber Node reconciliation, and `placeSingleChild()`
is where child Fiber Node is marked to do insertion on DOM.

```javascript
function placeSingleChild(newFiber: Fiber): Fiber {
  // This is simpler for the single child case. We only need to do a
  // placement for inserting new children.
  // ~ Yes, the flag is used here(well in some other places as well)
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    // ~ Placement means the DOM sub-tree needs to be inserted
    newFiber.flags |= Placement | PlacementDEV;
  }
  return newFiber;
}
```

Notice that this is done on `child,` meaning in initial mount, the child of `HostRoot` is
marked with `Placement`. In our demo code, it is `<App/>`.

### 3.10 `mountIndeterminateComponent()`

Next branch in `beginWork()` we'll look at is `IndeterminateComponent`. Since `<App/>` is under
HostRoot, and as mentioned already that Custom components are initially marked as `IndeterminateComponent`,
we'll come here when when first time `<App/>` is reconciled.

```javascript
function mountIndeterminateComponent(
  _current: null | Fiber,
  workInProgress: Fiber,
  Component: $FlowFixMe,
  renderLanes: Lanes,
) {
  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);

  const props = workInProgress.pendingProps;
  let context;
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(
      workInProgress,
      Component,
      false,
    );
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  let value;
  let hasId;

  // ~ This runs function components and return the children elements
  value = renderWithHooks(
    null,
    workInProgress,
    Component,
    props,
    context,
    renderLanes,
  );
  hasId = checkDidRenderIdHook();

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;

  if (
    // Run these checks in production only if the flag is off.
    // Eventually we'll delete this branch altogether.
    !disableModulePatternComponents &&
    typeof value === 'object' &&
    value !== null &&
    typeof value.render === 'function' &&
    value.$$typeof === undefined
  ) {
    // Proceed under the assumption that this is a class instance
    // ~ Once rendered, it is no long IndeterminateComponent
    workInProgress.tag = ClassComponent;

    ...
  } else {
    // Proceed under the assumption that this is a function component
    // ~ Once rendered, it is no long IndeterminateComponent
    workInProgress.tag = FunctionComponent;

    if (getIsHydrating() && hasId) {
      pushMaterializedTreeId(workInProgress);
    }

    // ~ since here current is null, so  mountChildFibers() will be used
    reconcileChildren(null, workInProgress, value, renderLanes);
    return workInProgress.child;
  }
}
```

As mentioned, when rendering `<App/>`, `mountChildFibers()` is used because
different from HostRoot which always has current, there is no previous version for `<App/>` and
`placeSingleChild()` ignores the insertion flags.

`App()` returns `<div>`, which later is handled by `HostComponent` branch
in `beginWork()`.

### 3.11 `updateHostComponent()`

```javascript
function updateHostComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  pushHostContext(workInProgress);

  if (current === null) {
    // ~ For hydration, refer to How basic hydration works internally in React
    tryToClaimNextHydratableInstance(workInProgress);
  }

  const type = workInProgress.type;
  // ~ pendingProps holds the children of <div/>, which is the <p/>
  const nextProps = workInProgress.pendingProps;
  const prevProps = current !== null ? current.memoizedProps : null;

  let nextChildren = nextProps.children;
  // ~ This is an improvement if its children are static text, as in <a/>
  const isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  ...

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

Above process repeats for `<p/>`, except that `nextChildren` now is an array,
so `reconcileChildrenArray()` kicks in inside `reconcileChildFibers()`.

`reconcileChildrenArray()` is a bit more complex because of the existence of `key`,
for more details go to my another blog post -
[How does 'key' work internally? List diffing in React](/react/2022/02/08/the-diffing-algorithm-for-array-in-react/).

Other than the `key` handling, it basically return the first child fiber and continues,
the siblings will be processed later since React flattens the tree structure into linked list.
For more, please refer to [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/).

For `<Link/>`, we are repeating the process as `<App/>`.

For `<a>` and `<button>` we'll go to deeper to its text.

But they are a bit different, `<a>` has a static text as children, while `<button>` has some JSX expression `{count}`.
That's why in above code, `<a>` has `nextChildren` as null, but `<button>` continues to children.

### 3.12 `updateHostText()`

For `<button>` its children is an array - `["click me - ", "0"]`, `updateHostText()` is the branch
for both of them in `beginWork()`.

```javascript
function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.

  return null;
}
```

But it does nothing except handling hydration. How the text in `<a>` and `<button>` are handled
is in the Commit phase.

### 3.13 DOM nodes are created offscreen in `completeWork()`.

As mentioned in [How does React traverse Fiber tree internally](/react/2022/01/16/fiber-traversal-in-react/),
`completeWork()` is called on a fiber before its sibling is tried with `beginWork()`.

Fiber Node has one important property - `stateNode`, which for intrinsic HTML tags, it refers
to the actual DOM node. And the actual creation of DOM node is done in `completeWork()`.

```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  // Note: This intentionally doesn't check if we're hydrating because comparing
  // to the current tree provider fiber is just as fast and less error-prone.
  // Ideally we would have a special version of the work loop only
  // for hydration.
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);
      return null;
    case ClassComponent: {
      const Component = workInProgress.type;
      if (isLegacyContextProvider(Component)) {
        popLegacyContext(workInProgress);
      }
      bubbleProperties(workInProgress);
      return null;
    }
    case HostRoot: {
      ...
      return null;
    }
    ...
    // ~ For HTMl tags
    case HostComponent: {
      popHostContext(workInProgress);
      const type = workInProgress.type;
      // ~ If there is current version, then we go to update branch
      if (current !== null && workInProgress.stateNode != null) {
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          renderLanes,
        );

        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      // ~ But we don't have current version yet, so we go to this mount branch
      } else {
        ...
        if (wasHydrated) {
          ...
        } else {
          const rootContainerInstance = getRootHostContainer();

          // ~ The actual DOM node
          const instance = createInstance(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
          // ~ This is important, when an DOM node is created
          // ~ It needs to be the parent of all direct connected DOM nodes of subtree
          appendAllChildren(instance, workInProgress, false, false);
          workInProgress.stateNode = instance;

         if (
            // ~ This will be covered soon!
            finalizeInitialChildren(
              instance,
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            markUpdate(workInProgress);
          }
        }

        if (workInProgress.ref !== null) {
          // If there is a ref on a host node we need to schedule a callback
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);

      ...
      return null;
    }
    case HostText: {
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
        const oldText = current.memoizedProps;
        // If we have an alternate, that means this is an update and we need
        // to schedule a side-effect to do the updates.
        updateHostText(current, workInProgress, oldText, newText);
      } else {
        ...
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          if (prepareToHydrateHostTextInstance(workInProgress)) {
            markUpdate(workInProgress);
          }
        } else {
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    ...
  }
}
```

## 4. Initial mount in Commit phase

By now:

1. the workInProgress version of Fiber Tree is finally constructed!
2. the backing DOM nodes are also created and organized!
3. flags are set on necessary fibers to help guide the DOM manipulation!

Now it's time to actually see how React manipulates the DOM.

### 4.1 `commitMutationEffects()`

Recall in [Overview of React internals](/2023-07-11-overall-of-react-internals)
we briefly explained Commit phase, we'll go deeper in `commitMutationEffects()`
which handles the DOM mutation.

```javascript
export function commitMutationEffects(
  root: FiberRoot,
  // ~ The Fiber Node of HostRoot, holding the newly built Fiber Tree
  finishedWork: Fiber,
  committedLanes: Lanes
) {
  inProgressLanes = committedLanes;
  inProgressRoot = root;

  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);
  inProgressLanes = null;
  inProgressRoot = null;
}
```

```javascript
function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  lanes: Lanes,
) {
  const current = finishedWork.alternate;
  const flags = finishedWork.flags;

  // The effect flag should be checked *after* we refine the type of fiber,
  // because the fiber tag is more specific. An exception is any flag related
  // to reconciliation, because those can be set on all fiber types.
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      // ~ This recursive call makes sure subtree is handled first
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      // ~ ReconciliationEffects means Insertion .etc.
      commitReconciliationEffects(finishedWork);

      ...

      return;
    }
    ...
    case HostComponent: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);
      ...
      return;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      ...
      return;
    }
    case HostRoot: {
      if (enableFloat && supportsResources) {
        prepareToCommitHoistables();

        const previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root.containerInfo);

        recursivelyTraverseMutationEffects(root, finishedWork, lanes);
        currentHoistableRoot = previousHoistableRoot;

        commitReconciliationEffects(finishedWork);
      } else {
        recursivelyTraverseMutationEffects(root, finishedWork, lanes);
        commitReconciliationEffects(finishedWork);
      }

      ...
      return;
    }
    ...
    default: {
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork);

      return;
    }
  }
}
```

```javascript
function recursivelyTraverseMutationEffects(
  root: FiberRoot,
  parentFiber: Fiber,
  lanes: Lanes
) {
  // Deletions effects can be scheduled on any fiber type. They need to happen
  // before the children effects hae fired.

  // ~ Deletion are handled differently
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      try {
        commitDeletionEffects(root, parentFiber, childToDelete);
      } catch (error) {
        captureCommitPhaseError(childToDelete, parentFiber, error);
      }
    }
  }

  const prevDebugFiber = getCurrentDebugFiberInDEV();
  if (parentFiber.subtreeFlags & MutationMask) {
    let child = parentFiber.child;
    while (child !== null) {
      setCurrentDebugFiberInDEV(child);
      commitMutationEffectsOnFiber(child, root, lanes);
      child = child.sibling;
    }
  }
  setCurrentDebugFiberInDEV(prevDebugFiber);
}
```

### 4.2 `commitReconciliationEffects`

`commitReconciliationEffects()` handles the Insertion, reordering .etc.

```javascript
function commitReconciliationEffects(finishedWork: Fiber) {
  // Placement effects (insertions, reorders) can be scheduled on any fiber
  // type. They needs to happen after the children effects have fired, but
  // before the effects on this fiber have fired.
  const flags = finishedWork.flags;
  // ~ Yep, the flag are checked here!
  if (flags & Placement) {
    try {
      commitPlacement(finishedWork);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    // Clear the "placement" from effect tag so that we know that this is
    // inserted, before any life-cycles like componentDidMount gets called.
    // TODO: findDOMNode doesn't rely on this any more but isMounted does
    // and isMounted is deprecated anyway so we should be able to kill this.
    finishedWork.flags &= ~Placement;
  }
  ...
}
```

So in our demo , Fiber Node of `<App/>` actually gets committed.

### 4.3 `commitPlacement()`

```javascript
function commitPlacement(finishedWork: Fiber): void {
  ...
  // Recursively insert all host nodes into the parent.
  const parentFiber = getHostParentFiber(finishedWork);
  // ~ Notice here we are checking parent fiber's type
  // ~ Because Insertion is done against parent node
  switch (parentFiber.tag) {
    case HostSingleton: {
      if (enableHostSingletons && supportsSingletons) {
        const parent: Instance = parentFiber.stateNode;
        const before = getHostSibling(finishedWork);
        // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        insertOrAppendPlacementNode(finishedWork, before, parent);
        break;
      }
      // Fall through
    }
    // ~ We won't touch this branch in initial mount
    case HostComponent: {
      const parent: Instance = parentFiber.stateNode;
      if (parentFiber.flags & ContentReset) {
        // Reset the text content of the parent before doing any insertions
        resetTextContent(parent);
        // Clear ContentReset from the effect tag
        parentFiber.flags &= ~ContentReset;
      }

      const before = getHostSibling(finishedWork);
      // We only have the top Fiber that was inserted but we need to recurse down its
      // children to find all the terminal nodes.
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }
    // ~ The Fiber Node that has Placement flag for initial mount is <App/>
    // ~ its parentFiber is HostRoot
    case HostRoot:
    case HostPortal: {
        // ~ the stateNode of HostRoot points to FiberRootNode
      const parent: Container = parentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
      break;
    }
    default:
      throw new Error(
        'Invalid host parent fiber. This error is likely caused by a bug ' +
          'in React. Please file an issue.',
      );
  }
}
```

The idea is to insert or append the DOM of `finishedWork` into parent container, at the right position.

```javascript
function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container
): void {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode = node.stateNode;
    // ~ if it is DOM elements, just insert it
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (
    tag === HostPortal ||
    (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)
  ) {
    // If the insertion itself is a portal, then we don't want to traverse
    // down its children. Instead, we'll get insertions from each child in
    // the portal directly.
    // If the insertion is a HostSingleton then it will be placed independently
  } else {
    // ~ For non-DOM elements, recursively handle their children
    const child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      let sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
```

And this is how the DOM is finally inserted.

## 5. Summary

Alright, we finally see how the DOM is created and inserted to the container.
So for initial mount,

1. Fiber Tree is lazily created during reconciliation, the backing DOM nodes are created and organized at the same time.
2. The direct child of `HostRoot` is marked as `Placement`.
3. In commit phase, we just find fiber with `Placement`. Since its parent is HostRoot, its DOM node is inserted into container.
